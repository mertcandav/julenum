import{_ as a,c as l,o as n,ah as e}from"./chunks/framework.CvtUal3J.js";const d=JSON.parse('{"title":"julenum/poly","description":"","frontmatter":{},"headers":[],"relativePath":"api/poly.md","filePath":"api/poly.md"}'),o={name:"api/poly.md"};function p(r,s,t,i,c,F){return n(),l("div",null,s[0]||(s[0]=[e(`<h1 id="julenum-poly" tabindex="-1">julenum/poly <a class="header-anchor" href="#julenum-poly" aria-label="Permalink to “julenum/poly”">​</a></h1><p>Package for polynomials.</p><h2 id="index" tabindex="-1">Index <a class="header-anchor" href="#index" aria-label="Permalink to “Index”">​</a></h2><p><a href="#term">struct Term</a><br><a href="#polynomial">type Polynomial</a><br>     <a href="#leadingcoef">fn LeadingCoef(*self): f64</a><br>     <a href="#zero">fn Zero(*self, tol: f64): bool</a><br>     <a href="#degree">fn Degree(*self): int</a><br>     <a href="#negate">fn Negate(mut *self, &amp;x: *Polynomial)</a><br>     <a href="#copy">fn Copy(mut *self, &amp;x: *Polynomial)</a><br>     <a href="#simplify">fn Simplify(mut *self, &amp;p: *Polynomial, tol: f64)</a><br>     <a href="#add">fn Add(mut *self, &amp;x: *Polynomial, &amp;y: *Polynomial, tol: f64)</a><br>     <a href="#sub">fn Sub(mut *self, &amp;x: *Polynomial, &amp;y: *Polynomial, tol: f64)</a><br>     <a href="#scale">fn Scale(mut *self, &amp;x: *Polynomial, k: f64, tol: f64)</a><br>     <a href="#mul">fn Mul(mut *self, &amp;x: *Polynomial, &amp;y: *Polynomial)</a><br>     <a href="#mulnaive">fn MulNaive(mut *self, &amp;x: *Polynomial, &amp;y: *Polynomial)</a><br>     <a href="#multol">fn MulTol(mut *self, &amp;x: *Polynomial, &amp;y: *Polynomial, tol: f64)</a><br>     <a href="#mulfft">fn MulFFT(mut *self, &amp;x: *Polynomial, &amp;y: *Polynomial, tol: f64)</a><br>     <a href="#divmod">fn DivMod(mut *self, &amp;x: *Polynomial, &amp;y: *Polynomial, mut &amp;rem: *Polynomial)</a><br>     <a href="#divmodnaive">fn DivModNaive(mut *self, &amp;x: *Polynomial, &amp;y: *Polynomial, mut &amp;rem: *Polynomial)</a><br>     <a href="#derivative">fn Derivative(mut *self, &amp;x: *Polynomial)</a><br>     <a href="#integral">fn Integral(mut *self, &amp;x: *Polynomial, C: f64)</a><br>     <a href="#eval">fn Eval(*self, x: f64): f64</a><br>     <a href="#gcd">fn GCD(mut *self, &amp;x: *Polynomial, &amp;y: *Polynomial, tol: f64)</a><br>     <a href="#lcm">fn LCM(mut *self, &amp;x: *Polynomial, &amp;y: *Polynomial, tol: f64)</a><br>     <a href="#pow">fn Pow(mut *self, &amp;x: *Polynomial, mut n: int)</a><br>     <a href="#normalize">fn Normalize(mut *self, &amp;x: *Polynomial, tol: f64)</a><br>     <a href="#interpolatelinear">fn InterpolateLinear(mut *self, x0: f64, y0: f64, x1: f64, y1: f64)</a><br>     <a href="#interpolatelagrange">fn InterpolateLagrange(mut *self, xs: []f64, ys: []f64, tol: f64)</a><br>     <a href="#appendformat">fn AppendFormat(*self, mut buf: []byte): []byte</a><br>     <a href="#str">fn Str(*self): str</a></p><h2 id="term" tabindex="-1">Term <a class="header-anchor" href="#term" aria-label="Permalink to “Term”">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">struct</span><span style="color:#F6F6F4;"> Term {</span></span>
<span class="line"><span style="color:#F6F6F4;">	Coef</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span></span>
<span class="line"><span style="color:#F6F6F4;">	Exp</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;">  </span><span style="color:#F286C4;">int</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Represents a single term (monomial) of a polynomial. It has a coefficient and an exponent (degree).</p><p>Mathematically, a term is expressed as:<br></p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#f6f6f4;">coef * x^exp</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>where:<br></p><ul><li>coef ∈ ℝ (coefficient, a real number)</li><li>exp ∈ ℕ₀ (non-negative integer exponent)</li></ul><p>For example:<br></p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#f6f6f4;">the term 3x² is represented as Term{Coef: 3, Exp: 2}.</span></span>
<span class="line"><span style="color:#f6f6f4;">the term x is represented as Term{Coef: 1, Exp: 1}.</span></span>
<span class="line"><span style="color:#f6f6f4;">the term 2x is represented as Term{Coef: 2, Exp: 1}.</span></span>
<span class="line"><span style="color:#f6f6f4;">the term 1 is represented as Term{Coef: 1, Exp: 0}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="polynomial" tabindex="-1">Polynomial <a class="header-anchor" href="#polynomial" aria-label="Permalink to “Polynomial”">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">type</span><span style="color:#F6F6F4;"> Polynomial: []Term</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Represents a polynomial as a slice of Terms.</p><p>A polynomial P(x) is a finite sum of terms:<br></p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#f6f6f4;">P(x) = Σᵢ [ Coefᵢ * x^Expᵢ ]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>where each Term is stored as an element of the Terms slice.</p><p>Terms are expected to be stored in descending order of exponent (Exp), i.e., Terms[0].Exp &gt; Terms[1].Exp &gt; ... &gt; Terms[n-1].Exp, which simplifies polynomial operations like addition and multiplication. Any corruption in this order is undefined behavior.</p><p>Capacity of underlying slices is never changed for values; i.e. that there are no 3-operand slice expressions. Any corruption of this rule is undefined behavior.</p><h3 id="leadingcoef" tabindex="-1">LeadingCoef <a class="header-anchor" href="#leadingcoef" aria-label="Permalink to “LeadingCoef”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">LeadingCoef</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Returns the leading coefficient of the polynomial. Panics if polynomial is zero.</p><h3 id="zero" tabindex="-1">Zero <a class="header-anchor" href="#zero" aria-label="Permalink to “Zero”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Zero</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, tol</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">bool</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Reports whether polynomial is zero within tolerance.</p><h3 id="degree" tabindex="-1">Degree <a class="header-anchor" href="#degree" aria-label="Permalink to “Degree”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Degree</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">int</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Returns the degree of the polynomial (highest exponent). Returns -1 for the zero polynomial.</p><h3 id="negate" tabindex="-1">Negate <a class="header-anchor" href="#negate" aria-label="Permalink to “Negate”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Negate</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to negated coefficients of the polynomial x. For example, (3x^2 - 4x + 1) becomes (-3x^2 + 4x - 1).</p><p>If self have enough capacity, Negate will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="copy" tabindex="-1">Copy <a class="header-anchor" href="#copy" aria-label="Permalink to “Copy”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Copy</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Copies polynomial x to self.</p><p>If self have enough capacity, Negate will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="simplify" tabindex="-1">Simplify <a class="header-anchor" href="#simplify" aria-label="Permalink to “Simplify”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Simplify</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">p</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, tol</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to simplified form of the polynomial p. IT merges like terms and removes zero coefficients with tolerance.</p><p>Result is sorted by decreasing exponent. If the Polynomial manually modified, this function may help to follow internal polynomial representation rules as described in Polynomial type.</p><p>If self have enough capacity, Simplify will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="add" tabindex="-1">Add <a class="header-anchor" href="#add" aria-label="Permalink to “Add”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Add</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, tol</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to sum x+y.</p><p>If self have enough capacity, Add will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="sub" tabindex="-1">Sub <a class="header-anchor" href="#sub" aria-label="Permalink to “Sub”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Sub</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, tol</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to difference x-y.</p><p>If self have enough capacity, Sub will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="scale" tabindex="-1">Scale <a class="header-anchor" href="#scale" aria-label="Permalink to “Scale”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Scale</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, k</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">, tol</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to scaled coefficients of x by scalar k. For example, if k = 2, (3x^2 - x) becomes (6x^2 - 2x).</p><p>If self have enough capacity, Scale will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="mul" tabindex="-1">Mul <a class="header-anchor" href="#mul" aria-label="Permalink to “Mul”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Mul</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to product x*y.</p><p>It is equals to MulTol(x, y, tol), but determines tolerance dynamically. Dynamic tolerance value might not be suitable for some cases. Use MulTol with custom tolerance when needed, especially for precise and small coefficients like 1e-14. However, small coefficients might be removed due to rounding errors during computation with custom tolerance.</p><p>For minimum rounding-errors, use MulNaive to force native algorithms. Naive algorithm is slower than FFT, but it is more accurate.</p><p>If self have enough capacity, Mul will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="mulnaive" tabindex="-1">MulNaive <a class="header-anchor" href="#mulnaive" aria-label="Permalink to “MulNaive”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">MulNaive</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to product x*y.</p><p>Like Mul but forces to naive algorithm and never uses FFT. Provides more accurate results, but slower for large polynomials.</p><p>If self have enough capacity, MulNaive will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="multol" tabindex="-1">MulTol <a class="header-anchor" href="#multol" aria-label="Permalink to “MulTol”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">MulTol</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, tol</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Sets self to product x*y.</p><p>Unlike Mul, this function takes custom tolerance and it uses for FFT. If FFT algorithm will not be used, tolerance will not be used.</p><p>Algorithm will select naive algorithm of FFT to compute, which one is efficient for the case.</p><p>If self have enough capacity, MulTol will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="mulfft" tabindex="-1">MulFFT <a class="header-anchor" href="#mulfft" aria-label="Permalink to “MulFFT”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">MulFFT</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, tol</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Sets self to product x*y.</p><p>Like MulTol but forces to FFT and never uses naive algorithm. Provides faster computations for large polynomaisl, but less accurate.</p><p>If self have enough capacity, MulFFT will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="divmod" tabindex="-1">DivMod <a class="header-anchor" href="#divmod" aria-label="Permalink to “DivMod”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">DivMod</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, </span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">rem</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Sets self to quotient x/y, sets rem to remainder x/y if it is not nil. Panics for divide by zero.</p><p>It uses naive division for small inputs, FFT division for larger inputs. When FFT division used, accuracy decreased due to floating-point rounding. Especiall remainder is less accurate compared to naive division.</p><p>For minimum rounding-errors, use DivModNaive to force native division. Naive algorithm is slower than FFT, but it is more accurate.</p><p>If self and rem have enough capacity, DivMod will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="divmodnaive" tabindex="-1">DivModNaive <a class="header-anchor" href="#divmodnaive" aria-label="Permalink to “DivModNaive”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">DivModNaive</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, </span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">rem</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Sets self to quotient x/y, sets rem to remainder x/y if it is not nil. Panics for divide by zero.</p><p>Like DivMod but forces to naive algorithm and never uses FFT. Provides more accurate results, but slower for large polynomials.</p><p>If self and rem have enough capacity, DivMod will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="derivative" tabindex="-1">Derivative <a class="header-anchor" href="#derivative" aria-label="Permalink to “Derivative”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Derivative</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to the first derivative of polynomial x.</p><p>If x = ∑ᵢ [ aᵢ * xⁱ ], then self = ∑ᵢ [ (i*aᵢ)·xⁱ⁻¹ ] for i ≥ 1. Constant terms (exp = 0) are omitted.</p><p>If self have enough capacity, Derivative will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="integral" tabindex="-1">Integral <a class="header-anchor" href="#integral" aria-label="Permalink to “Integral”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Integral</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, C</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to the indefinite integral of polynomial x with constant term C. That is, integrates each term and appends a constant term.</p><p>If self have enough capacity, Integral will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="eval" tabindex="-1">Eval <a class="header-anchor" href="#eval" aria-label="Permalink to “Eval”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Eval</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Evaluates the polynomial at a given x.</p><h3 id="gcd" tabindex="-1">GCD <a class="header-anchor" href="#gcd" aria-label="Permalink to “GCD”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">GCD</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, tol</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Sets self to the greatest common divisor of two polynomials x and y. Leading coefficient is normalized to 1 (if not zero).</p><p>If self have enough capacity, GCD will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="lcm" tabindex="-1">LCM <a class="header-anchor" href="#lcm" aria-label="Permalink to “LCM”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">LCM</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, tol</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Sets self to the least common multiple of two polynomials x and y. Leading coefficient is normalized to 1 (if not zero).</p><p>If self have enough capacity, LCM will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="pow" tabindex="-1">Pow <a class="header-anchor" href="#pow" aria-label="Permalink to “Pow”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Pow</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, </span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> n</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">int</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to product x^n. Condition n &gt;= 0 must be true.</p><p>If self have enough capacity, Pow will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="normalize" tabindex="-1">Normalize <a class="header-anchor" href="#normalize" aria-label="Permalink to “Normalize”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Normalize</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Polynomial, tol</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to rescaled polynomial x, so that its leading coefficient is 1. If the polynomial is zero or leading coefficient is very small, output length is zero.</p><p>If self have enough capacity, Normalize will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="interpolatelinear" tabindex="-1">InterpolateLinear <a class="header-anchor" href="#interpolatelinear" aria-label="Permalink to “InterpolateLinear”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">InterpolateLinear</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, x0</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">, y0</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">, x1</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">, y1</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to the unique linear polynomial that passes through points (x0, y0) and (x1, y1).</p><p>If self have enough capacity, InterpolateLinear will use it to avoid making allocation.</p><h3 id="interpolatelagrange" tabindex="-1">InterpolateLagrange <a class="header-anchor" href="#interpolatelagrange" aria-label="Permalink to “InterpolateLagrange”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">InterpolateLagrange</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, xs</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> []</span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">, ys</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> []</span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">, tol</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to the unique degree-(n-1) polynomial that passes through the given points using the Lagrange interpolation formula. Panics if input lengths differ or have duplicate x values.</p><p>If self have enough capacity, InterpolateLagrance will use it to avoid making allocation. If length is zero, self will be zero-length. But keeps internal allocation.</p><h3 id="appendformat" tabindex="-1">AppendFormat <a class="header-anchor" href="#appendformat" aria-label="Permalink to “AppendFormat”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">AppendFormat</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> buf</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> []</span><span style="color:#F286C4;">byte</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> []</span><span style="color:#F286C4;">byte</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Appends a human-readable string representation of the polynomial to buf and returns.</p><h3 id="str" tabindex="-1">Str <a class="header-anchor" href="#str" aria-label="Permalink to “Str”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Str</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">str</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Returns a human-readable string representation of the polynomial.</p>`,130)]))}const u=a(o,[["render",p]]);export{d as __pageData,u as default};
