import{_ as a,c as n,o as e,ah as l}from"./chunks/framework.CvtUal3J.js";const u=JSON.parse('{"title":"julenum/interp","description":"","frontmatter":{},"headers":[],"relativePath":"api/interp.md","filePath":"api/interp.md"}'),p={name:"api/interp.md"};function o(t,s,r,i,c,d){return e(),n("div",null,s[0]||(s[0]=[l(`<h1 id="julenum-interp" tabindex="-1">julenum/interp <a class="header-anchor" href="#julenum-interp" aria-label="Permalink to “julenum/interp”">​</a></h1><p>Package for interpolation computations.</p><h2 id="index" tabindex="-1">Index <a class="header-anchor" href="#index" aria-label="Permalink to “Index”">​</a></h2><p><a href="#linear">fn Linear(x: f64, xp: []f64, fp: []f64): f64</a><br><a href="#lagrange">fn Lagrange(x: f64, xp: []f64, fp: []f64): f64</a><br><a href="#newton">fn Newton(x: f64, xp: []f64, fp: []f64): f64</a><br><a href="#barycentric">struct Barycentric</a><br>     <a href="#init">fn Init(mut *self, mut xp: []f64, mut fp: []f64, tol: f64)</a><br>     <a href="#interpolate">fn Interpolate(*self, x: f64): f64</a></p><h2 id="linear" tabindex="-1">Linear <a class="header-anchor" href="#linear" aria-label="Permalink to “Linear”">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Linear</span><span style="color:#F6F6F4;">(x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">, xp</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> []</span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">, fp</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> []</span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Computes one-dimensional piecewise linear interpolation.</p><p>Given a set of monotonically increasing sample points xp and their corresponding function values fp, it estimates the value of the underlying function at a point x by linear interpolation between the nearest points in xp.</p><p>xp must be sorted in strictly ascending order, otherwise the result is undefined. xp and fp must be have same length and non-empty.</p><p>Boundary behavior:<br></p><ul><li>If x &lt; xp[0], it returns fp[0] (constant extrapolation).</li><li>If x &gt; xp[len(xp)-1], it returns fp[len(fp)-1] (constant extrapolation).</li></ul><h2 id="lagrange" tabindex="-1">Lagrange <a class="header-anchor" href="#lagrange" aria-label="Permalink to “Lagrange”">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Lagrange</span><span style="color:#F6F6F4;">(x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">, xp</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> []</span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">, fp</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> []</span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Computes Lagrange polynomial interpolation for given points (xp, fp) and evaluates the polynomial at x.</p><p>xp and fp slices must be of the same length &gt; 0, and xp points should be distinct.</p><p>Mathematically, the Lagrange interpolation polynomial is defined as:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#f6f6f4;">P(x) = ∑_{j=0}^{n-1} [ fⱼ * Lⱼ(x) ], where:</span></span>
<span class="line"><span style="color:#f6f6f4;">Lⱼ(x) = ∏_{m=0, m≠j}^{n-1} [ (x - xₘ) / (xⱼ - xₘ) ]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="newton" tabindex="-1">Newton <a class="header-anchor" href="#newton" aria-label="Permalink to “Newton”">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Newton</span><span style="color:#F6F6F4;">(x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">, xp</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> []</span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">, fp</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> []</span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Computes Newton polynomial interpolation for given points (xp, fp) and evaluates the polynomial at x.</p><p>xp and fp slices must be of the same length &gt; 0, and xp points should be distinct.</p><p>Mathematically, the Newton interpolation polynomial is defined as:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#f6f6f4;">P(x) = f₀ + ∑_{j=1}^{n-1} [ f[x₀, x₁, ..., xⱼ] * ∏_{m=0}^{j-1} (x - xₘ) ], where:</span></span>
<span class="line"><span style="color:#f6f6f4;">f[x₀, x₁, ..., xⱼ] are the divided differences computed recursively by:</span></span>
<span class="line"><span style="color:#f6f6f4;">	f[xⱼ] = fⱼ,</span></span>
<span class="line"><span style="color:#f6f6f4;">	f[xᵢ, ..., x_{i+k}] = (f[x_{i+1}, ..., x_{i+k}] - f[xᵢ, ..., x_{i+k-1}]) / (x_{i+k} - xᵢ)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="barycentric" tabindex="-1">Barycentric <a class="header-anchor" href="#barycentric" aria-label="Permalink to “Barycentric”">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">struct</span><span style="color:#F6F6F4;"> Barycentric {</span></span>
<span class="line"><span style="color:#F6F6F4;">	</span><span style="color:#7B7F8B;">// NOTE: contains filtered hidden or unexported fields</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Implements Barycentric form of Lagrange polynomial interpolation.</p><p>Given distinct sample points xp and their corresponding values fp, it precomputes Barycentric weights wⱼ:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#f6f6f4;">wⱼ = 1 / ∏_{m=0, m≠j}^{n-1} [ (xⱼ - xₘ) ]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>The interpolation polynomial at point x is then evaluated by:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#f6f6f4;">P(x) = ∑_{j=0}^{n-1} [ (wⱼ / (x - xⱼ)) * fⱼ ] / ∑_{j=0}^{n-1} [ wⱼ / (x - xⱼ) ]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>If x coincides with some xⱼ, P(x) = fⱼ exactly (no division by zero).</p><p>This form is numerically stable and efficient for multiple evaluations.</p><h3 id="init" tabindex="-1">Init <a class="header-anchor" href="#init" aria-label="Permalink to “Init”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Init</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> xp</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> []</span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> fp</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> []</span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">, tol</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Initializes the Barycentric interpolator for given points. xp and fp must have the same length (&gt;0) and contain distinct points. It precomputes Barycentric weights wⱼ used in interpolation.</p><p>Uses mutable copy of xp and fp. The behavior and results are undefined, if any mutation performed after initialization.</p><h3 id="interpolate" tabindex="-1">Interpolate <a class="header-anchor" href="#interpolate" aria-label="Permalink to “Interpolate”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Interpolate</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Computes the Barycentric interpolation polynomial at x.</p><p>If x equals some sample point xpⱼ, returns fpⱼ directly.</p><p>Otherwise, computes:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#f6f6f4;">P(x) = ∑ⱼ [ wⱼ / (x - xⱼ)) * fⱼ ] / ∑ⱼ [ wⱼ / (x - xⱼ) ]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Interpolation must be initialized by Init, otherwise behavior is undefined.</p>`,43)]))}const y=a(p,[["render",o]]);export{u as __pageData,y as default};
