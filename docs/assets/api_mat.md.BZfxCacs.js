import{_ as a,c as n,o as e,ah as l}from"./chunks/framework.CvtUal3J.js";const u=JSON.parse('{"title":"julenum/mat","description":"","frontmatter":{},"headers":[],"relativePath":"api/mat.md","filePath":"api/mat.md"}'),o={name:"api/mat.md"};function p(r,s,t,c,i,F){return e(),n("div",null,s[0]||(s[0]=[l(`<h1 id="julenum-mat" tabindex="-1">julenum/mat <a class="header-anchor" href="#julenum-mat" aria-label="Permalink to “julenum/mat”">​</a></h1><p>Package for matrices.</p><h2 id="index" tabindex="-1">Index <a class="header-anchor" href="#index" aria-label="Permalink to “Index”">​</a></h2><p><a href="#empty">fn Empty[T: numeric](): Matrix[T]</a><br><a href="#new">fn New[T: numeric](m: int, n: int): Matrix[T]</a><br><a href="#newfrom">fn NewFrom[T: numeric](values: [][]T): Matrix[T]</a><br><a href="#matrix">struct Matrix[T: numeric]</a><br>     <a href="#dims">fn Dims(*self): (m: int, n: int)</a><br>     <a href="#size">fn Size(*self): int</a><br>     <a href="#zero">fn Zero(*self): bool</a><br>     <a href="#square">fn Square(*self): bool</a><br>     <a href="#scalar">fn Scalar(*self, c: T): bool</a><br>     <a href="#identity">fn Identity(*self): bool</a><br>     <a href="#diagonal">fn Diagonal(*self): bool</a><br>     <a href="#get">fn Get(*self, i: int, j: int): T</a><br>     <a href="#set">fn Set(mut *self, i: int, j: int, value: T)</a><br>     <a href="#equal">fn Equal(*self, &amp;z: *Matrix[T]): bool</a><br>     <a href="#fill">fn Fill(mut *self, &amp;z: *Matrix[T], k: T)</a><br>     <a href="#copy">fn Copy(mut *self, &amp;z: *Matrix[T])</a><br>     <a href="#resize">fn Resize(mut *self, &amp;z: *Matrix[T], m: int, n: int)</a><br>     <a href="#trace">fn Trace(*self): T</a><br>     <a href="#transpose">fn Transpose(mut *self, &amp;z: *Matrix[T])</a><br>     <a href="#addscalar">fn AddScalar(mut *self, &amp;z: *Matrix[T], k: T)</a><br>     <a href="#subscalar">fn SubScalar(mut *self, &amp;z: *Matrix[T], k: T)</a><br>     <a href="#mulscalar">fn MulScalar(mut *self, &amp;z: *Matrix[T], k: T)</a><br>     <a href="#add">fn Add(mut *self, &amp;x: *Matrix[T], &amp;y: *Matrix[T])</a><br>     <a href="#sub">fn Sub(mut *self, &amp;x: *Matrix[T], &amp;y: *Matrix[T])</a><br>     <a href="#mul">fn Mul(mut *self, &amp;x: *Matrix[T], &amp;y: *Matrix[T])</a><br>     <a href="#det">fn Det(*self): T</a><br>     <a href="#slogdet">fn Slogdet(*self): (sign: T, logdet: f64)</a><br>     <a href="#inv">fn Inv(mut *self, &amp;a: *Matrix[T])</a><br>     <a href="#format">fn Format(*self, wsn: int): str</a><br>     <a href="#appendformat">fn AppendFormat(*self, mut buf: []byte, wsn: int): []byte</a><br>     <a href="#str">fn Str(*self): str</a></p><h2 id="empty" tabindex="-1">Empty <a class="header-anchor" href="#empty" aria-label="Permalink to “Empty”">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Empty</span><span style="color:#F6F6F4;">[T</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> numeric]()</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> Matrix[T]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Returns new empty (0×0) Matrix for type T.</p><h2 id="new" tabindex="-1">New <a class="header-anchor" href="#new" aria-label="Permalink to “New”">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">New</span><span style="color:#F6F6F4;">[T</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> numeric](m</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">int</span><span style="color:#F6F6F4;">, n</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">int</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> Matrix[T]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Returns new (M×N) zero Matrix for type T.</p><p>Constraints:<br></p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#f6f6f4;">m &gt;= 0</span></span>
<span class="line"><span style="color:#f6f6f4;">n &gt;= 0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="newfrom" tabindex="-1">NewFrom <a class="header-anchor" href="#newfrom" aria-label="Permalink to “NewFrom”">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">NewFrom</span><span style="color:#F6F6F4;">[T</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> numeric](values</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> [][]T)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> Matrix[T]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Returns new (M×N) Matrix for type T. Uses len(values) for m, len(values[1]) for n. Panics if all rows are not have same amount of values.</p><p>Special cases are:<br></p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#f6f6f4;">NewFrom(values) = (0×0) Matrix, if len(values) == 0</span></span>
<span class="line"><span style="color:#f6f6f4;">NewFrom(values) = (0×0) Matrix, if len(values) == 1 &amp;&amp; len(values[1]) == 0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Example Use:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#f6f6f4;">mat::NewFrom([</span></span>
<span class="line"><span style="color:#f6f6f4;">	[1, 2, 4],</span></span>
<span class="line"><span style="color:#f6f6f4;">	[3, 4, 5],</span></span>
<span class="line"><span style="color:#f6f6f4;">])</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">Equals to:</span></span>
<span class="line"><span style="color:#f6f6f4;">	A = ⎡1 2 4⎤</span></span>
<span class="line"><span style="color:#f6f6f4;">	    ⎣3 4 5⎦(2×3)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="matrix" tabindex="-1">Matrix <a class="header-anchor" href="#matrix" aria-label="Permalink to “Matrix”">​</a></h2><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">struct</span><span style="color:#F6F6F4;"> Matrix[T</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> numeric] {</span></span>
<span class="line"><span style="color:#F6F6F4;">	</span><span style="color:#7B7F8B;">// NOTE: contains filtered hidden or unexported fields</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>A matrix for type T. Uses internal mutable slice to store data. Matrix computations may use available capacity of the underlying slice to avoid making new allocation. So shared data needs extra attention. Any mutable operation may be reflected to shared common data. If you need to share same Matrix instance, use smart pointers. If you need to have guaranteed independent copy, use Copy with empty Matrix.</p><h3 id="dims" tabindex="-1">Dims <a class="header-anchor" href="#dims" aria-label="Permalink to “Dims”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Dims</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> (m</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">int</span><span style="color:#F6F6F4;">, n</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">int</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Returns dimensions of the Matrix (M×N).</p><h3 id="size" tabindex="-1">Size <a class="header-anchor" href="#size" aria-label="Permalink to “Size”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Size</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">int</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Returns total element count of matrix (M×N).</p><h3 id="zero" tabindex="-1">Zero <a class="header-anchor" href="#zero" aria-label="Permalink to “Zero”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Zero</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">bool</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Reports whether the all values of Matrix are zero.</p><p>Special cases are:<br></p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#f6f6f4;">Zero() = true, if Dims() == (0, 0)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="square" tabindex="-1">Square <a class="header-anchor" href="#square" aria-label="Permalink to “Square”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Square</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">bool</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Reports whether the Matrix is a square matrix (M == N).</p><h3 id="scalar" tabindex="-1">Scalar <a class="header-anchor" href="#scalar" aria-label="Permalink to “Scalar”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Scalar</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, c</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> T)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">bool</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Reports whether the matrice (M×N) is scalar matrice of c. This function only supports square matrices (M == N &amp;&amp; N &gt; 0).</p><h3 id="identity" tabindex="-1">Identity <a class="header-anchor" href="#identity" aria-label="Permalink to “Identity”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Identity</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">bool</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Reports whether the matrice (M×N) is an identity matrice. This function only supports square matrices (M == N &amp;&amp; N &gt; 0).</p><h3 id="diagonal" tabindex="-1">Diagonal <a class="header-anchor" href="#diagonal" aria-label="Permalink to “Diagonal”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Diagonal</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">bool</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Reports whether the matrice (M×N) is a diagonal matrice. This function only supports square matrices (M == N &amp;&amp; N &gt; 0).</p><h3 id="get" tabindex="-1">Get <a class="header-anchor" href="#get" aria-label="Permalink to “Get”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Get</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, i</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">int</span><span style="color:#F6F6F4;">, j</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">int</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> T</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Returns value of the specified (i×j) position. Position index starts from zero for column and row.</p><p>Implementation will not check for boundaries, invalid position may cause panic. To provide fast computation, it will not check whether the (i×j) is valid (M×N).</p><h3 id="set" tabindex="-1">Set <a class="header-anchor" href="#set" aria-label="Permalink to “Set”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Set</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, i</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">int</span><span style="color:#F6F6F4;">, j</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">int</span><span style="color:#F6F6F4;">, value</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> T)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Sets value of the specified (i×j) position. Position index starts from zero for column and row.</p><p>Implementation will not check for boundaries, invalid position may cause panic. To provide fast computation, it will not check whether the (i×j) is valid (M×N).</p><h3 id="equal" tabindex="-1">Equal <a class="header-anchor" href="#equal" aria-label="Permalink to “Equal”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Equal</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">z</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Matrix[T])</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">bool</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Reports whether self and z matrices are equal.</p><h3 id="fill" tabindex="-1">Fill <a class="header-anchor" href="#fill" aria-label="Permalink to “Fill”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Fill</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">z</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Matrix[T], k</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> T)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to z, filled with k. If self have enough capacity, Fill will use it to avoid making allocation.</p><h3 id="copy" tabindex="-1">Copy <a class="header-anchor" href="#copy" aria-label="Permalink to “Copy”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Copy</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">z</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Matrix[T])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Copies z to self.</p><p>If self have enough capacity, Copy will use it to avoid making allocation.</p><h3 id="resize" tabindex="-1">Resize <a class="header-anchor" href="#resize" aria-label="Permalink to “Resize”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Resize</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">z</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Matrix[T], m</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">int</span><span style="color:#F6F6F4;">, n</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">int</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Copies matrice z to self with custom (M×N) size. If new size is larger, it will add padding with zeros. If new size is smaller, it will cut rows and columns.</p><p>If self have enough capacity, Resize will use it to avoid making allocation. If M == 0 or N == 0, self will be (0×0). But keeps internal allocation.</p><h3 id="trace" tabindex="-1">Trace <a class="header-anchor" href="#trace" aria-label="Permalink to “Trace”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Trace</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> T</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Returns trace of matrix. Panics if matrix is not a square matrix.</p><p>Special cases are:<br></p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#f6f6f4;">Trace() = 0, for (0×0) matrices</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="transpose" tabindex="-1">Transpose <a class="header-anchor" href="#transpose" aria-label="Permalink to “Transpose”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Transpose</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">z</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Matrix[T])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to the transpose of the matrix z. If self have enough capacity, Transpose will use it to avoid making allocation. If z is a (0×0) matrix, self will be (0×0). But keeps internal allocation.</p><h3 id="addscalar" tabindex="-1">AddScalar <a class="header-anchor" href="#addscalar" aria-label="Permalink to “AddScalar”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">AddScalar</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">z</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Matrix[T], k</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> T)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to the sum z+k. If self have enough capacity, AddScalar will use it to avoid making allocation. If z is a (0×0) matrix, self will be (0×0). But keeps internal allocation.</p><h3 id="subscalar" tabindex="-1">SubScalar <a class="header-anchor" href="#subscalar" aria-label="Permalink to “SubScalar”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">SubScalar</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">z</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Matrix[T], k</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> T)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to the difference z-k. If self have enough capacity, SubScalar will use it to avoid making allocation. If z is a (0×0) matrix, self will be (0×0). But keeps internal allocation.</p><h3 id="mulscalar" tabindex="-1">MulScalar <a class="header-anchor" href="#mulscalar" aria-label="Permalink to “MulScalar”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">MulScalar</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">z</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Matrix[T], k</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> T)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to the product z*k. If self have enough capacity, MulScalar will use it to avoid making allocation. If z is a (0×0) matrix, self will be (0×0). But keeps internal allocation.</p><h3 id="add" tabindex="-1">Add <a class="header-anchor" href="#add" aria-label="Permalink to “Add”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Add</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Matrix[T], </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Matrix[T])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to the sum x+y. If self have enough capacity, Add will use it to avoid making allocation. If matrices are (0×0) matrix, self will be (0×0). But keeps internal allocation.</p><h3 id="sub" tabindex="-1">Sub <a class="header-anchor" href="#sub" aria-label="Permalink to “Sub”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Sub</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Matrix[T], </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Matrix[T])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to the difference x-y. If self have enough capacity, Sub will use it to avoid making allocation. If matrices are (0×0) matrix, self will be (0×0). But keeps internal allocation.</p><h3 id="mul" tabindex="-1">Mul <a class="header-anchor" href="#mul" aria-label="Permalink to “Mul”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Mul</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Matrix[T], </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Matrix[T])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Sets self to the product x*y. If self have enough capacity, Mul will use it to avoid making allocation.</p><h3 id="det" tabindex="-1">Det <a class="header-anchor" href="#det" aria-label="Permalink to “Det”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Det</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> T</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Computes the determinant of the matrix. This function only supports square matrices (M == N &amp;&amp; N &gt; 0).</p><p>For integer and floating-point types, computations are performed using 64-bit floating-point precision. For complex types, computations use 128-bit complex precision. The result is returned as type T, which may cause rounding errors or loss of precision. To preserve exact results, use an f64 or cmplx128 matrix.</p><h3 id="slogdet" tabindex="-1">Slogdet <a class="header-anchor" href="#slogdet" aria-label="Permalink to “Slogdet”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#BF9EEE;">#disable</span><span style="color:#F6F6F4;"> boundary</span></span>
<span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Slogdet</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> (sign</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> T, logdet</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">f64</span><span style="color:#F6F6F4;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Computes the sign and natural logarithm of the absolute value of the determinant of the matrix. Returns (sign, logdet). If the matrix is singular, returns (0, -Inf). This function only supports square matrices (M == N &amp;&amp; N &gt; 0).</p><p>For integer and floating-point types, computations are performed using 64-bit floating-point precision. For complex types, computations use 128-bit complex precision. The result is returned as type T, which may cause rounding errors or loss of precision. To preserve exact results, use an f64 or cmplx128 matrix.</p><p>NOTICE (floating-point types)<br></p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#f6f6f4;">Let (sign, logdet) = Slogdet()</span></span>
<span class="line"><span style="color:#f6f6f4;">- Mathematically: Det() = sign * exp(logdet)</span></span>
<span class="line"><span style="color:#f6f6f4;">- In practice:    Det() ≈ sign * exp(logdet)</span></span>
<span class="line"><span style="color:#f6f6f4;">                  due to floating-point rounding.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>NOTICE (complex types)<br></p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#f6f6f4;">Let (sign, logdet) = Slogdet()</span></span>
<span class="line"><span style="color:#f6f6f4;">- Mathematically: Det() = cmplx(real(sign)*exp(logdet), imag(sign)*exp(logdet))</span></span>
<span class="line"><span style="color:#f6f6f4;">- In practive:    Det() ≈ cmplx(real(sign)*exp(logdet), imag(sign)*exp(logdet))</span></span>
<span class="line"><span style="color:#f6f6f4;">                  due to floating-point rounding.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="inv" tabindex="-1">Inv <a class="header-anchor" href="#inv" aria-label="Permalink to “Inv”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Inv</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;">a</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;">Matrix[T])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Sets self to A⁻¹, inverse of the matrix a. This function only supports square matrices (M == N &amp;&amp; N &gt; 0). If self have enough capacity, Mul will use it to avoid making allocation. It panics if matrix a is singular.</p><p>For integer and floating-point types, computations are performed using 64-bit floating-point precision. For complex types, computations use 128-bit complex precision. The result is handled as type T, which may cause rounding errors or loss of precision. To preserve exact results, use an f64 or cmplx128 matrix.</p><h3 id="format" tabindex="-1">Format <a class="header-anchor" href="#format" aria-label="Permalink to “Format”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Format</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, wsn</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">int</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">str</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Returns string form of the matrix. wsn represents number of whitespaces between matrix elements. wsn will be considired as zero if wsn &lt; 1. Default wsn value is 1.</p><h3 id="appendformat" tabindex="-1">AppendFormat <a class="header-anchor" href="#appendformat" aria-label="Permalink to “AppendFormat”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">AppendFormat</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">mut</span><span style="color:#F6F6F4;"> buf</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> []</span><span style="color:#F286C4;">byte</span><span style="color:#F6F6F4;">, wsn</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">int</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> []</span><span style="color:#F286C4;">byte</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Appends string form of the matrix to buf and returns. wsn represents number of whitespaces between matrix elements. wsn will be considired as zero if wsn &lt; 1. Default wsn value is 1.</p><h3 id="str" tabindex="-1">Str <a class="header-anchor" href="#str" aria-label="Permalink to “Str”">​</a></h3><div class="language-jule line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jule</span><pre class="shiki dracula-soft" style="background-color:#0000000;" tabindex="0"><code><span class="line"><span style="color:#F286C4;">fn</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Str</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">*self</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">str</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Returns string form of the matrix.</p>`,118)]))}const y=a(o,[["render",p]]);export{u as __pageData,y as default};
