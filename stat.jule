// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/math"

// Computes the chi-square statistic between two vectors: observed and expected.
// The lengths of obs and exp must be equal, otherwise it panics.
//
// Mathematically, the chi-square statistic is defined as:
//	χ² = Σᵢ [ (Oᵢ - Eᵢ)² / Eᵢ ]
//	where:
//		Oᵢ = observed value at index i,
//		Eᵢ = expected value at index i,
//		and the summation is over all elements.
#disable boundary
fn ChiSquare[T: float](obs: []T, exp: []T): T {
	if len(obs) != len(exp) {
		panic("julenum: ChiSquare: different vector lengths")
	}
	let mut r: T
	mut i := 0
	for i < len(obs); i++ {
		x, y := obs[i], exp[i]
		if x == 0 && y == 0 {
			continue
		}
		diff := x - y
		r += (diff * diff) / y
	}
	ret r
}

// Computes the chi-square distance between two vectors: x and y.
// The lengths of x and y must be equal, otherwise it panics.
//
// Mathematically, the chi-square distance is defined as:
//	χ² = 1/2 * Σᵢ [ (xᵢ - yᵢ)² / (xᵢ + yᵢ) ]
#disable boundary
fn ChiSquareDistance[T: float](x: []T, y: []T): T {
	if len(x) != len(y) {
		panic("julenum: ChiSquareDistance: different vector lengths")
	}
	let mut r: T
	mut i := 0
	for i < len(x); i++ {
		xi, yi := x[i], y[i]
		if xi == 0 && yi == 0 {
			continue
		}
		diff := xi - yi
		r += (diff * diff) / (xi + yi)
	}
	ret 0.5 * r
}

// Computes the mean of the data set x.
//
// Mathematically, the mean is defined as:
//	Mean = Σᵢ [ xᵢ ] / n
fn Mean[T: integer | float](x: []T): T {
	if len(x) == 0 {
		ret 0
	}
	ret Sum(x...) / T(len(x))
}

// Computes the weighted mean of the data set x.
//
// Mathematically, the weighted mean is defined as:
//	Mean = Σᵢ [ wᵢ * xᵢ ] / Σᵢ [ wᵢ ]
//
// If len(weights) == 0, then all of the weights are 1.
// Otherwise len(weights) must be equal to len(x).
#disable boundary
fn MeanWeight[T: integer | float](x: []T, weights: []T): T {
	if len(weights) == 0 {
		ret Mean(x)
	}
	if len(x) != len(weights) {
		panic("julenum: MeanWeight: len(x) != len(weights)")
	}
	let mut sumX: T
	let mut sumW: T
	mut i := 0
	for i < len(x); i++ {
		w := weights[i]
		sumX += w * x[i]
		sumW += w
	}
	ret sumX / sumW
}

// Computes the geometric mean of the data set x.
//
// Mathematically, the geometric mean is defined as:
//	G = (x₁ * x₂ * ... * xₙ)^(1/n)
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
fn GeometricMean[T: integer | float](x: []T): T {
	if len(x) == 0 {
		ret 0
	}
	mut logSum := 0.0
	for _, x_i in x {
		logSum += math::Log(f64(x_i))
	}
	logSum /= f64(len(x))
	ret T(math::Exp(logSum))
}

// Computes the weighted geometric mean of the data set x.
//
// Mathematically, the weighted geometric mean is defined as:
//	G = (x₁^w₁ * x₂^w₂ * ... * xₙ^wₙ)^(1 / Σᵢ [ wᵢ ])
//
// If len(weights) == 0, then all of the weights are 1.
// Otherwise len(weights) must be equal to len(x).
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
#disable boundary
fn GeometricMeanWeight[T: integer | float](x: []T, weights: []T): T {
	if len(weights) == 0 {
		ret GeometricMean(x)
	}
	if len(x) != len(weights) {
		panic("julenum: GeometricMeanWeight: len(x) != len(weights)")
	}
	mut logSum, mut weightsSum := 0.0, 0.0
	mut i := 0
	for i < len(x); i++ {
		w := f64(weights[i])
		logSum += w * math::Log(x[i])
		weightsSum += w
	}
	logSum /= weightsSum
	ret math::Exp(logSum)
}

// Computes the harmonic mean of the data set x.
//
// Mathematically, the harmonic mean is defined as:
//	H = n / Σᵢ [ 1 / xᵢ ]
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
#disable boundary
fn HarmonicMean[T: integer | float](x: []T): T {
	if len(x) == 0 {
		ret 0
	}
	mut z := 0.0
	mut i := 0
	for i < len(x); i++ {
		z += 1 / f64(x[i])
	}
	ret T(f64(len(x)) / z)
}

// Computes the weighted harmonic mean of the data set x.
//
// Mathematically, the weighted harmonic mean is defined as:
//	H = Σᵢ [ wᵢ ] / Σᵢ [ wᵢ/xᵢ ]
//
// If len(weights) == 0, then all of the weights are 1.
// Otherwise len(weights) must be equal to len(x).
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
#disable boundary
fn HarmonicMeanWeight[T: integer | float](x: []T, weights: []T): T {
	if len(weights) == 0 {
		ret HarmonicMean(x)
	}
	if len(x) != len(weights) {
		panic("julenum: HarmonicMeanWeight: len(x) != len(weights)")
	}
	mut weightedSum, mut weightsSum := 0.0, 0.0
	mut i := 0
	for i < len(x); i++ {
		w := f64(weights[i])
		weightedSum += w / f64(x[i])
		weightsSum += w
	}
	ret T(weightsSum / weightedSum)
}

// Computes the root mean square of the data set x.
//
// Mathematically, the root mean square is defined as:
//	RMS = √(Σᵢ [ xᵢ² ] / n)
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
#disable boundary
fn RootMeanSquare[T: integer | float](x: []T): T {
	if len(x) == 0 {
		ret 0
	}
	let mut z: T
	mut i := 0
	for i < len(x); i++ {
		z += x[i] * x[i]
	}
	z /= T(len(x))
	ret T(math::Sqrt(f64(z)))
}

// Computes the weighted root mean square of the data set x.
//
// Mathematically, the weighted root mean square is defined as:
//	RMS = √(Σᵢ [ wᵢ*xᵢ² ] / Σᵢ [ wᵢ ])
//
// If len(weights) == 0, then all of the weights are 1.
// Otherwise len(weights) must be equal to len(x).
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
#disable boundary
fn RootMeanSquareWeight[T: integer | float](x: []T, weights: []T): T {
	if len(weights) == 0 {
		ret RootMeanSquare(x)
	}
	if len(x) != len(weights) {
		panic("julenum: RootMeanSquareWeight: len(x) != len(weights)")
	}
	mut weightedSum, mut weightsSum := T(0), T(0)
	mut i := 0
	for i < len(x); i++ {
		w_i, x_i := weights[i], x[i]
		weightedSum += w_i * x_i * x_i
		weightsSum += w_i
	}
	ret T(math::Sqrt(f64(weightedSum / weightsSum)))
}

// Computes the circular mean of the data set x.
//
// Mathematically, the circular mean is defined as:
//	C = atan2(Σᵢ [ sin(xᵢ) ], Σᵢ [ cos(xᵢ) ])
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
#disable boundary
fn CircularMean[T: integer | float](x: []T): T {
	if len(x) == 0 {
		ret 0
	}
	mut sumSin, mut sumCos := 0.0, 0.0
	mut i := 0
	for i < len(x); i++ {
		x_i := f64(x[i])
		sumSin += math::Sin(x_i)
		sumCos += math::Cos(x_i)
	}
	ret T(math::Atan2(sumSin, sumCos))
}

// Computes the weighted circular mean of the data set x.
//
// Mathematically, the weighted circular mean is defined as:
//	C = atan2(Σᵢ [ wᵢ * sin(xᵢ) ], Σᵢ [ wᵢ * cos(xᵢ) ])
//
// If len(weights) == 0, then all of the weights are 1.
// Otherwise len(weights) must be equal to len(x).
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
#disable boundary
fn CircularMeanWeight[T: integer | float](x: []T, weights: []T): T {
	if len(weights) == 0 {
		ret CircularMean(x)
	}
	if len(x) != len(weights) {
		panic("julenum: CircularMeanWeight: len(x) != len(weights)")
	}
	mut sumSin, mut sumCos := 0.0, 0.0
	mut i := 0
	for i < len(x); i++ {
		w_i, x_i := f64(weights[i]), f64(x[i])
		sumSin += w_i * math::Sin(x_i)
		sumCos += w_i * math::Cos(x_i)
	}
	ret T(math::Atan2(sumSin, sumCos))
}

fn medianInPlace[T: integer | float](mut x: []T): f64 {
	n := len(x)
	mid := n >> 1
	if n&1 == 1 {
		ret quickSelect(x, mid)
	}
	// For even n, average two middle values.
	lo := quickSelect(x, mid-1)
	hi := quickSelect(x, mid)
	ret (lo + hi) / 2
}

// Computes the median of the data set x.
// This function allocates a new copy of x to avoid modifying the original data.
// If preserving the original data is not necessary or x won't be used afterward,
// consider using MedianInPlace for better performance and zero allocation.
#disable boundary
fn Median[T: integer | float](x: []T): f64 {
	if len(x) == 0 {
		panic("julenum: Median: median of empty slice")
	}
	mut xc := make([]T, len(x))
	copy(xc, x)
	ret medianInPlace(xc)
}

// Computes the median of the data set x in-place (modifies x).
// This function mutates the input slice, and its final ordering is undefined.
// Designed for zero-allocation, memory-efficient use cases.
// If the original data must be preserved or x will be used afterward, use Median instead.
fn MedianInPlace[T: integer | float](mut x: []T): f64 {
	if len(x) == 0 {
		panic("julenum: MedianInPlace: median of empty slice")
	}
	medianInPlace(x)
}

// This function computes the Pearson correlation coefficient using
// a numerically stable two-pass algorithm as recommended by:
// Chan, Tony F., Gene H. Golub, and Randall J. LeVeque,
// “Algorithms for computing the sample variance: Analysis and recommendations”
//
// The two-pass method first computes the mean, then computes
// the variance and covariance using the means, reducing floating-point errors.
// The covariance results are unnormalised.
fn meanCovariance[T: integer | float](x: []T, y: []T, weights: []T): (sumW: f64, meanX: f64, meanY: f64, varX: f64, varY: f64, covXY: f64) {
	mut compensationX, mut compensationY := 0.0, 0.0
	if len(weights) == 0 {
		sumW = f64(len(x))

		// Manually inlined version of the Mean function for x and y.
		mut i := 0
		for i < len(x); i++ {
			meanX += f64(x[i])
			meanY += f64(y[i])
		}
		meanX /= f64(len(x))
		meanY /= f64(len(y))

		i = 0
		for i < len(x); i++ {
			dx := f64(x[i]) - meanX
			dy := f64(y[i]) - meanY
			varX += dx * dx
			varY += dy * dy
			covXY += dx * dy
			compensationX += dx
			compensationY += dy
		}
	} else {
		// Manually inlined version of the MeanWeight function for x and y.
		mut i := 0
		for i < len(x); i++ {
			wi := f64(weights[i])
			meanX += wi * f64(x[i])
			meanY += wi * f64(y[i])
			sumW += wi
		}
		meanX /= sumW
		meanY /= sumW

		i = 0
		for i < len(x); i++ {
			dx := f64(x[i]) - meanX
			dy := f64(y[i]) - meanY
			wi := f64(weights[i])
			widx := wi * dx
			widy := wi * dy
			varX += widx * dx
			varY += widy * dy
			covXY += widx * dy
			compensationX += widx
			compensationY += widy
		}
	}

	varX -= compensationX * compensationX / sumW
	varY -= compensationY * compensationY / sumW
	covXY -= compensationX * compensationY / sumW

	ret sumW, meanX, meanY, varX, varY, covXY
}

// Computes the Pearson correlation coefficient between two data sets x and y.
// Length of data sets must be equal. Returns 0 if lenghts are zero.
//
// Mathematically, the Pearson correlation coefficient is defined as:
//	r = Σᵢ [ (xᵢ - x̄)(yᵢ - ȳ) ] / √(Σᵢ [ (xᵢ - x̄)² ]) * √(Σᵢ [ (yᵢ - ȳ)² ])
#disable boundary
fn Correlation[T: integer | float](x: []T, y: []T): f64 {
	if len(x) != len(y) {
		panic("julenum: Correlation: len(x) != len(y)")
	}
	if len(x) == 0 {
		ret 0
	}
	_, _, _, varX, varY, covXY := meanCovariance(x, y, nil)
	denominator := math::Sqrt(varX * varY)
	if denominator == 0 {
		ret 0
	}
	ret covXY / denominator
}

// Computes the weighted Pearson correlation coefficient between two data sets x and y.
// Length of data sets must be equal. Returns 0 if lenghts are zero.
//
// Mathematically, the weighted Pearson correlation coefficient is defined as:
//	r_w = Σᵢ [ wᵢ * (xᵢ - x̄_w)(yᵢ - ȳ_w) ] / √(Σᵢ [ wᵢ * (xᵢ - x̄_w)² ]) * √(Σᵢ [ wᵢ * (yᵢ - ȳ_w)² ])
//
// If len(weights) == 0, then all of the weights are 1.
// Otherwise len(weights) must be equal to the data sets lengths.
#disable boundary
fn CorrelationWeight[T: integer | float](x: []T, y: []T, weights: []T): f64 {
	if len(weights) == 0 {
		ret Correlation(x, y)
	}
	if len(x) != len(y) || len(x) != len(weights) {
		panic("julenum: CorrelationWeight: len(x) != len(y) != len(weights)")
	}
	if len(x) == 0 {
		ret 0
	}
	_, _, _, varX, varY, covXY := meanCovariance(x, y, weights)
	denominator := math::Sqrt(varX * varY)
	if denominator == 0 {
		ret 0
	}
	ret covXY / denominator
}

// This function computes the variance using
// a numerically stable two-pass algorithm as recommended by:
// Chan, Tony F., Gene H. Golub, and Randall J. LeVeque,
// “Algorithms for computing the sample variance: Analysis and recommendations”
//
// The two-pass method first computes the mean, then computes
// the variance using the mean, reducing floating-point errors.
fn meanVariance[T: integer | float](x: []T, weights: []T): (meanX: f64, varX: f64) {
	mut n := f64(len(x))
	mut compensationX := 0.0
	if len(weights) == 0 {
		// Manually inlined version of the Mean function for x.
		mut i := 0
		for i < len(x); i++ {
			meanX += f64(x[i])
		}
		meanX /= n

		i = 0
		for i < len(x); i++ {
			dx := f64(x[i]) - meanX
			varX += dx * dx
			compensationX += dx
		}
	} else {
		// Manually inlined version of the MeanWeight function for x.
		mut sumW := 0.0
		mut i := 0
		for i < len(x); i++ {
			wi := f64(weights[i])
			meanX += wi * f64(x[i])
			sumW += wi
		}
		n = sumW
		meanX /= n

		i = 0
		for i < len(x); i++ {
			wi := f64(weights[i])
			dx := f64(x[i]) - meanX
			widx := wi * dx
			varX += widx * dx
			compensationX += widx
		}
	}

	varX -= compensationX * compensationX / n
	varX /= n - 1
	ret
}

// Computes the mean and the unbiased sample variance of the data set x.
// This is faster than calling Mean and Variance functions separately.
// Unlike Mean, it returns mean in 64-bit floating-point precision.
//
// Mathematically, the mean is defined as:
//	Mean = Σᵢ [ xᵢ ] / n
//
// Mathematically, the unbiased sample variance is defined as:
//	var(x) = Σᵢ [ (xᵢ - x̄)² ] / (n - 1)
fn MeanVariance[T: integer | float](x: []T): (f64, f64) {
	ret meanVariance(x, nil)
}

// Computes the unbiased sample variance of the data set x.
//
// Mathematically, the unbiased sample variance is defined as:
//	var(x) = Σᵢ [ (xᵢ - x̄)² ] / (n - 1)
fn Variance[T: integer | float](x: []T): f64 {
	_, varX := meanVariance(x, nil)
	ret varX
}

// Computes the weighted mean and the weighted unbiased sample variance of the data set x.
// This is faster than calling MeanWeight and VarianceWeight functions separately.
// Unlike MeanWeight, it returns mean in 64-bit floating-point precision.
//
// Mathematically, the weighted mean is defined as:
//	Mean = Σᵢ [ wᵢ * xᵢ ] / Σᵢ [ wᵢ ]
//
// Mathematically, the weighted unbiased sample variance is defined as:
//	var(x) = Σᵢ [ wᵢ * (xᵢ - x̄)² ] / (Σᵢ [ wᵢ ] - 1)
//
// If len(weights) == 0, then all of the weights are 1.
// Otherwise len(weights) must be equal to len(x).
fn MeanVarianceWeight[T: integer | float](x: []T, weights: []T): (f64, f64) {
	if len(weights) != 0 && len(x) != len(weights) {
		panic("julenum: MeanVarianceWeight: len(x) != len(weights)")
	}
	ret meanVariance(x, weights)
}

// Computes the weighted unbiased sample variance of the data set x.
//
// Mathematically, the weighted unbiased sample variance is defined as:
//	var(x) = Σᵢ [ wᵢ * (xᵢ - x̄)² ] / (Σᵢ [ wᵢ ] - 1)
//
// If len(weights) == 0, then all of the weights are 1.
// Otherwise len(weights) must be equal to len(x).
fn VarianceWeight[T: integer | float](x: []T, weights: []T): f64 {
	if len(weights) != 0 && len(x) != len(weights) {
		panic("julenum: VarianceWeight: len(x) != len(weights)")
	}
	_, varX := meanVariance(x, weights)
	ret varX
}