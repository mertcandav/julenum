// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/math"

// Computes the chi-square statistic between two vectors: observed and expected.
// The lengths of obs and exp must be equal, otherwise it panics.
//
// Mathematically, the chi-square statistic is defined as:
//	χ² = Σᵢ [ (Oᵢ - Eᵢ)² / Eᵢ ]
//	where:
//		Oᵢ = observed value at index i,
//		Eᵢ = expected value at index i,
//		and the summation is over all elements.
#disable boundary
fn ChiSquare[T: float](obs: []T, exp: []T): T {
	if len(obs) != len(exp) {
		panic("julenum: ChiSquare: different vector lengths")
	}
	let mut r: T
	mut i := 0
	for i < len(obs); i++ {
		x, y := obs[i], exp[i]
		if x == 0 && y == 0 {
			continue
		}
		diff := x - y
		r += (diff * diff) / y
	}
	ret r
}

// Computes the chi-square distance between two vectors: x and y.
// The lengths of x and y must be equal, otherwise it panics.
//
// Mathematically, the chi-square distance is defined as:
//	χ² = 1/2 * Σᵢ [ (xᵢ - yᵢ)² / (xᵢ + yᵢ) ]
#disable boundary
fn ChiSquareDistance[T: float](x: []T, y: []T): T {
	if len(x) != len(y) {
		panic("julenum: ChiSquareDistance: different vector lengths")
	}
	let mut r: T
	mut i := 0
	for i < len(x); i++ {
		xi, yi := x[i], y[i]
		if xi == 0 && yi == 0 {
			continue
		}
		diff := xi - yi
		r += (diff * diff) / (xi + yi)
	}
	ret 0.5 * r
}

// Computes the mean of the data set x.
//
// Mathematically, the mean is defined as:
//	Mean = Σᵢ [ xᵢ ] / n
fn Mean[T: integer | float](x: []T): T {
	if len(x) == 0 {
		ret 0
	}
	ret Sum(x...) / T(len(x))
}

// Computes the weighted mean of the data set x.
//
// Mathematically, the weighted mean is defined as:
//	Mean = Σᵢ [ wᵢ * xᵢ ] / Σᵢ [ wᵢ ]
//
// If len(weights) == 0, then all of the weights are 1.
// Otherwise len(weights) must be equal to len(x).
#disable boundary
fn MeanWeight[T: integer | float](x: []T, weights: []T): T {
	if len(weights) == 0 {
		ret Mean(x)
	}
	if len(x) != len(weights) {
		panic("julenum: MeanWeight: len(x) != len(weights)")
	}
	let mut sumX: T
	let mut sumW: T
	mut i := 0
	for i < len(x); i++ {
		w := weights[i]
		sumX += w * x[i]
		sumW += w
	}
	ret sumX / sumW
}

// Computes the geometric mean of the data set x.
//
// Mathematically, the geometric mean is defined as:
//	G = (x₁ * x₂ * ... * xₙ)^(1/n)
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
fn GeometricMean[T: integer | float](x: []T): T {
	if len(x) == 0 {
		ret 0
	}
	mut logSum := 0.0
	for _, x_i in x {
		logSum += math::Log(f64(x_i))
	}
	logSum /= f64(len(x))
	ret T(math::Exp(logSum))
}

// Computes the weighted geometric mean of the data set x.
//
// Mathematically, the weighted geometric mean is defined as:
//	G = (x₁^w₁ * x₂^w₂ * ... * xₙ^wₙ)^(1 / Σᵢ [ wᵢ ])
//
// If len(weights) == 0, then all of the weights are 1.
// Otherwise len(weights) must be equal to len(x).
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
#disable boundary
fn GeometricMeanWeight[T: integer | float](x: []T, weights: []T): T {
	if len(weights) == 0 {
		ret GeometricMean(x)
	}
	if len(x) != len(weights) {
		panic("julenum: GeometricMeanWeight: len(x) != len(weights)")
	}
	mut logSum, mut weightsSum := 0.0, 0.0
	mut i := 0
	for i < len(x); i++ {
		w := f64(weights[i])
		logSum += w * math::Log(x[i])
		weightsSum += w
	}
	logSum /= weightsSum
	ret math::Exp(logSum)
}

// Computes the harmonic mean of the data set x.
//
// Mathematically, the harmonic mean is defined as:
//	H = n / Σᵢ [ 1 / xᵢ ]
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
#disable boundary
fn HarmonicMean[T: integer | float](x: []T): T {
	if len(x) == 0 {
		ret 0
	}
	mut z := 0.0
	mut i := 0
	for i < len(x); i++ {
		z += 1 / f64(x[i])
	}
	ret T(f64(len(x)) / z)
}

// Computes the weighted harmonic mean of the data set x.
//
// Mathematically, the weighted harmonic mean is defined as:
//	H = Σᵢ [ wᵢ ] / Σᵢ [ wᵢ/xᵢ ]
//
// If len(weights) == 0, then all of the weights are 1.
// Otherwise len(weights) must be equal to len(x).
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
#disable boundary
fn HarmonicMeanWeight[T: integer | float](x: []T, weights: []T): T {
	if len(weights) == 0 {
		ret HarmonicMean(x)
	}
	if len(x) != len(weights) {
		panic("julenum: HarmonicMeanWeight: len(x) != len(weights)")
	}
	mut weightedSum, mut weightsSum := 0.0, 0.0
	mut i := 0
	for i < len(x); i++ {
		w := f64(weights[i])
		weightedSum += w / f64(x[i])
		weightsSum += w
	}
	ret T(weightsSum / weightedSum)
}

// Computes the root mean square of the data set x.
//
// Mathematically, the root mean square is defined as:
//	RMS = √(Σᵢ [ xᵢ² ] / n)
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
#disable boundary
fn RootMeanSquare[T: integer | float](x: []T): T {
	if len(x) == 0 {
		ret 0
	}
	let mut z: T
	mut i := 0
	for i < len(x); i++ {
		z += x[i] * x[i]
	}
	z /= T(len(x))
	ret T(math::Sqrt(f64(z)))
}

// Computes the weighted root mean square of the data set x.
//
// Mathematically, the weighted root mean square is defined as:
//	RMS = √(Σᵢ [ wᵢ*xᵢ² ] / Σᵢ [ wᵢ ])
//
// If len(weights) == 0, then all of the weights are 1.
// Otherwise len(weights) must be equal to len(x).
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
#disable boundary
fn RootMeanSquareWeight[T: integer | float](x: []T, weights: []T): T {
	if len(weights) == 0 {
		ret RootMeanSquare(x)
	}
	if len(x) != len(weights) {
		panic("julenum: RootMeanSquareWeight: len(x) != len(weights)")
	}
	mut weightedSum, mut weightsSum := T(0), T(0)
	mut i := 0
	for i < len(x); i++ {
		w_i, x_i := weights[i], x[i]
		weightedSum += w_i * x_i * x_i
		weightsSum += w_i
	}
	ret T(math::Sqrt(f64(weightedSum / weightsSum)))
}

// Computes the circular mean of the data set x.
//
// Mathematically, the circular mean is defined as:
//	x̄ = atan2(Σᵢ [ sin(xᵢ) ], Σᵢ [ cos(xᵢ) ])
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
#disable boundary
fn CircularMean[T: integer | float](x: []T): T {
	if len(x) == 0 {
		ret 0
	}
	mut sumSin, mut sumCos := 0.0, 0.0
	mut i := 0
	for i < len(x); i++ {
		x_i := f64(x[i])
		sumSin += math::Sin(x_i)
		sumCos += math::Cos(x_i)
	}
	ret T(math::Atan2(sumSin, sumCos))
}

// Computes the weighted circular mean of the data set x.
//
// Mathematically, the weighted circular mean is defined as:
//	x̄ = atan2(Σᵢ [ wᵢ * sin(xᵢ) ], Σᵢ [ wᵢ * cos(xᵢ) ])
//
// If len(weights) == 0, then all of the weights are 1.
// Otherwise len(weights) must be equal to len(x).
//
// Computations are performed using 64-bit floating-point precision.
// The result is returned as type T, which may cause rounding errors or loss of precision.
// To preserve exact results, use an f64 data set.
#disable boundary
fn CircularMeanWeight[T: integer | float](x: []T, weights: []T): T {
	if len(weights) == 0 {
		ret CircularMean(x)
	}
	if len(x) != len(weights) {
		panic("julenum: CircularMeanWeight: len(x) != len(weights)")
	}
	mut sumSin, mut sumCos := 0.0, 0.0
	mut i := 0
	for i < len(x); i++ {
		w_i, x_i := f64(weights[i]), f64(x[i])
		sumSin += w_i * math::Sin(x_i)
		sumCos += w_i * math::Cos(x_i)
	}
	ret T(math::Atan2(sumSin, sumCos))
}

fn medianInPlace[T: integer | float](mut x: []T): f64 {
	n := len(x)
	mid := n >> 1
	if n&1 == 1 {
		ret quickSelect(x, mid)
	}
	// For even n, average two middle values.
	lo := quickSelect(x, mid-1)
	hi := quickSelect(x, mid)
	ret (lo + hi) / 2
}

// Computes the median of the data set x.
// This function allocates a new copy of x to avoid modifying the original data.
// If preserving the original data is not necessary or x won't be used afterward,
// consider using MedianInPlace for better performance and zero allocation.
#disable boundary
fn Median[T: integer | float](x: []T): f64 {
	if len(x) == 0 {
		panic("julenum: Median: median of empty slice")
	}
	mut xc := make([]T, len(x))
	copy(xc, x)
	ret medianInPlace(xc)
}

// Computes the median of the data set x in-place (modifies x).
// This function mutates the input slice, and its final ordering is undefined.
// Designed for zero-allocation, memory-efficient use cases.
// If the original data must be preserved or x will be used afterward, use Median instead.
fn MedianInPlace[T: integer | float](mut x: []T): f64 {
	if len(x) == 0 {
		panic("julenum: MedianInPlace: median of empty slice")
	}
	medianInPlace(x)
}