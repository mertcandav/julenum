// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "julenum"
use "std/math"
use "std/testing"

struct quatArithTest {
	x: Quat
	y: Quat
	f: f64

	rAdd:   Quat
	rSub:   Quat
	rMul:   Quat
	rScale: Quat
}

let testsQuatArith: []quatArithTest = [
	{
		x: {1, 1, 1, 1}, y: {1, 1, 1, 1},
		f: 2,
		rAdd: {2, 2, 2, 2},
		rSub: {0, 0, 0, 0},
		rMul: {-2, 2, 2, 2},
		rScale: {2, 2, 2, 2},
	},
	{
		x: {1, 1, 1, 1}, y: {2, -1, 1, -1},
		f: -2,
		rAdd: {3, 0, 2, 0},
		rSub: {-1, 2, 0, 2},
		rMul: {3, -1, 3, 3},
		rScale: {-2, -2, -2, -2},
	},
	{
		x: {1, 2, 3, 4}, y: {4, -3, 2, -1},
		f: 2,
		rAdd: {5, -1, 5, 3},
		rSub: {-3, 5, 1, 5},
		rMul: {8, -6, 4, 28},
		rScale: {2, 4, 6, 8},
	},
	{
		x: {1, 2, 3, 4}, y: {-4, 3, -2, 1},
		f: -2,
		rAdd: {-3, 5, 1, 5},
		rSub: {5, -1, 5, 3},
		rMul: {-8, 6, -4, -28},
		rScale: {-2, -4, -6, -8},
	},
	{
		x: {-4, 3, -2, 1}, y: {1, 2, 3, 4},
		f: 0.5,
		rAdd: {-3, 5, 1, 5},
		rSub: {-5, 1, -5, -3},
		rMul: {-8, -16, -24, -2},
		rScale: {-2, 1.5, -1, 0.5},
	},
]

#test
fn testQuatAdd(t: &testing::T) {
	for _, test in testsQuatArith {
		mut x, y := test.x, test.y
		x.Add(&x, &y)
		if x != test.rAdd {
			t.Errorf("expected {}, found {}, for Add({}, {})", test.rAdd, x, test.x, test.y)
		}
	}
}

#test
fn testQuatSub(t: &testing::T) {
	for _, test in testsQuatArith {
		mut x, y := test.x, test.y
		x.Sub(&x, &y)
		if x != test.rSub {
			t.Errorf("expected {}, found {}, for Sub({}, {})", test.rSub, x, test.x, test.y)
		}
	}
}

#test
fn testQuatMul(t: &testing::T) {
	for _, test in testsQuatArith {
		mut x, y := test.x, test.y
		x.Mul(&x, &y)
		if x != test.rMul {
			t.Errorf("expected {}, found {}, for Mul({}, {})", test.rMul, x, test.x, test.y)
		}
	}
}

#test
fn testQuatScale(t: &testing::T) {
	for _, test in testsQuatArith {
		mut x := test.x
		x.Scale(&x, test.f)
		if x != test.rScale {
			t.Errorf("expected {}, found {}, for Scale({}, {})", test.rScale, x, test.x, test.f)
		}
	}
}

let nan = math::NaN()
let inf = math::Inf(1)

struct testQuatBool {
	q: Quat
	r: bool
}

let testsQuatNaN: []testQuatBool = [
	{q: NaN(), r: true},
	{q: {R: nan, I: nan, J: nan, K: nan}, r: true},
	{q: {R: nan, I: 0, J: 0, K: 0}, r: true},
	{q: {R: 0, I: nan, J: 0, K: 0}, r: true},
	{q: {R: 0, I: 0, J: nan, K: 0}, r: true},
	{q: {R: 0, I: 0, J: 0, K: nan}, r: true},
	{q: {R: inf, I: nan, J: nan, K: nan}, r: false},
	{q: {R: nan, I: inf, J: nan, K: nan}, r: false},
	{q: {R: nan, I: nan, J: inf, K: nan}, r: false},
	{q: {R: nan, I: nan, J: nan, K: inf}, r: false},
	{q: {R: -inf, I: nan, J: nan, K: nan}, r: false},
	{q: {R: nan, I: -inf, J: nan, K: nan}, r: false},
	{q: {R: nan, I: nan, J: -inf, K: nan}, r: false},
	{q: {R: nan, I: nan, J: nan, K: -inf}, r: false},
	{q: {}, r: false},
]

#test
fn testQuatNaN(t: &testing::T) {
	for _, test in testsQuatNaN {
		r := test.q.NaN()
		if r != test.r {
			t.Errorf("expected {}, found {}, for NaN({})", test.r, r, test.q)
		}
	}
}

let testsQuatInf: []testQuatBool = [
	{q: Inf(0), r: true},
	{q: {R: inf, I: inf, J: inf, K: inf}, r: true},
	{q: {R: -inf, I: -inf, J: -inf, K: -inf}, r: true},
	{q: {R: inf, I: nan, J: nan, K: nan}, r: true},
	{q: {R: nan, I: inf, J: nan, K: nan}, r: true},
	{q: {R: nan, I: nan, J: inf, K: nan}, r: true},
	{q: {R: nan, I: nan, J: nan, K: inf}, r: true},
	{q: {R: -inf, I: nan, J: nan, K: nan}, r: true},
	{q: {R: nan, I: -inf, J: nan, K: nan}, r: true},
	{q: {R: nan, I: nan, J: -inf, K: nan}, r: true},
	{q: {R: nan, I: nan, J: nan, K: -inf}, r: true},
	{q: {R: inf}, r: true},
	{q: {I: inf}, r: true},
	{q: {J: inf}, r: true},
	{q: {K: inf}, r: true},
	{q: {R: -inf}, r: true},
	{q: {I: -inf}, r: true},
	{q: {J: -inf}, r: true},
	{q: {K: -inf}, r: true},
	{q: {}, r: false},
]

#test
fn testQuatInf(t: &testing::T) {
	for _, test in testsQuatInf {
		r := test.q.Inf()
		if r != test.r {
			t.Errorf("expected {}, found {}, for Inf({})", test.r, r, test.q)
		}
	}
}

struct testQuatF64 {
	q: Quat
	r: f64
}

let testsQuatAbs: []testQuatF64 = [
	{q: {}, r: 0},
	{q: NaN(), r: nan},
	{q: Inf(0), r: inf},
	{q: {R: 1, I: 1, J: 1, K: 1}, r: 2},
	{q: {R: -1, I: 1, J: -1, K: 1}, r: 2},
	{q: {R: 1, I: 2, J: 3, K: 4}, r: math::Sqrt(1 + 4 + 9 + 16)},
	{q: {R: -1, I: -2, J: -3, K: -4}, r: math::Sqrt(1 + 4 + 9 + 16)},
]

#test
fn testQuatAbs(t: &testing::T) {
	for _, test in testsQuatAbs {
		r := test.q.Abs()
		if math::IsNaN(test.r) {
			if !math::IsNaN(r) {
				t.Errorf("expected {}, found {}, for Abs({})", test.r, r, test.q)
			}
			continue
		}
		if r != test.r {
			t.Errorf("expected {}, found {}, for Inf({})", test.r, r, test.q)
		}
	}
}

// r = want NaN
let testsQuatInv: []testQuatBool = [
	{q: {R: 1, I: 1, J: 1, K: 1}},
	{q: {R: 3, I: -1, J: 5, K: -40}},
	{q: {R: 1e6, I: -1e5, J: 4, K: -10}},
	{q: {R: 0, I: 1, J: 1, K: 1}},
	{q: {R: 1, I: 0, J: 1, K: 1}},
	{q: {R: 1, I: 1, J: 0, K: 1}},
	{q: {R: 1, I: 1, J: 1, K: 0}},
	{q: {}, r: true},
]

#test
fn testQuatInv(t: &testing::T) {
	for _, test in testsQuatInv {
		mut r := test.q
		r.Inv(&r)
		r.Mul(&r, &test.q)
		if test.r { // want NaN
			if !r.NaN() {
				t.Errorf("expected NaN, found {}, for Inv({})", r, test.q)
			}
			continue
		}
		if !julenum::Close(r.R, 1) || !julenum::Close(r.Abs(), 1) {
			t.Errorf("expected R=1, found {}, for Inv({})", r, test.q)
		}
	}
}

struct testQuatQuat {
	q: Quat
	r: Quat
}

let testsQuatExp: []testQuatQuat = [
	{q: {}, r: {R: 1}},
	// Expected velues below are from pyquaternion.
	{
		q: {R: 1, I: 1, J: 1, K: 1},
		r: {R: -0.43643792124786496, I: 1.549040352371697, J: 1.549040352371697, K: 1.549040352371697},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1},
		r: {R: 0.42389891174348104, I: 0, J: 1.8986002490721081, K: 1.8986002490721081},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1},
		r: {R: 1.4686939399158851, I: 0, J: 0, K: 2.2873552871788423},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1},
		r: {R: -0.16055653857469052, I: 0.569860099182514, J: 0.569860099182514, K: 0.569860099182514},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1},
		r: {R: 0.15594369476537437, I: 0, J: 0.6984559986366083, K: 0.6984559986366083},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1},
		r: {R: 0.5403023058681398, I: 0, J: 0, K: 0.8414709848078965},
	},
]

#test
fn testQuatExp(t: &testing::T) {
	for _, test in testsQuatExp {
		mut x := test.q
		x.Exp(&x)
		if !equalApprox(x, test.r) {
			t.Errorf("expected {}, found {}, for Exp({})", test.r, x, test.q)
		}
	}
}

let testsQuatLog: []testQuatQuat = [
	{q: {}, r: {R: -inf}},
	// Expected velues below are from pyquaternion.
	{
		q: {R: 1, I: 1, J: 1, K: 1},
		r: {R: 0.6931471805599453, I: 0.6045997880780728, J: 0.6045997880780728, K: 0.6045997880780728},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1},
		r: {R: 0.5493061443340548, I: 0, J: 0.6755108588560398, K: 0.6755108588560398},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1},
		r: {R: 0.3465735902799727, I: 0, J: 0, K: 0.7853981633974484},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1},
		r: {R: 0.5493061443340548, I: 0.906899682117109, J: 0.906899682117109, K: 0.906899682117109},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1},
		r: {R: 0.3465735902799727, I: 0, J: 1.1107207345395915, K: 1.1107207345395915},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1},
		r: {R: 0, I: 0, J: 0, K: 1.5707963267948966},
	},
]

#test
fn testQuatLog(t: &testing::T) {
	for _, test in testsQuatLog {
		mut x := test.q
		x.Log(&x)
		if !equalApprox(x, test.r) {
			t.Errorf("expected {}, found {}, for Log({})", test.r, x, test.q)
		}
	}
}

struct quatPowTest {
	q: Quat
	r: Quat
	w: Quat
}

let testsQuatPow: []quatPowTest = [
	{q: {}, r: {}, w: {R: 1}},
	// Expected velues below are from pyquaternion.
	// pyquaternion does not support quaternion powers.
	{
		q: {R: 1, I: 1, J: 1, K: 1}, r: {R: 2},
		w: {R: -2, I: 2, J: 2, K: 2},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1}, r: {R: 2},
		w: {R: -1, I: 0, J: 2, K: 2},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1}, r: {R: 2},
		w: {R: 0, I: 0, J: 0, K: 2},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1}, r: {R: 2},
		w: {R: -3, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1}, r: {R: 2},
		w: {R: -2, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1}, r: {R: 2},
		w: {R: -1, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 1, I: 1, J: 1, K: 1}, r: {R: math::Pi},
		w: {R: -8.728144138959564, I: -0.7527136547040768, J: -0.7527136547040768, K: -0.7527136547040768},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1}, r: {R: math::Pi},
		w: {R: -5.561182514695044, I: 0, J: 0.5556661490713818, K: 0.5556661490713818},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1}, r: {R: math::Pi},
		w: {R: -2.320735561810013, I: 0, J: 0, K: 1.8544983901925216},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1}, r: {R: math::Pi},
		w: {R: 1.2388947209955585, I: -3.162774128856231, J: -3.162774128856231, K: -3.162774128856231},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1}, r: {R: math::Pi},
		w: {R: 0.6552860151073727, I: 0, J: -2.0488506614051922, K: -2.0488506614051922},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1}, r: {R: math::Pi},
		w: {R: 0.22058404074969779, I: 0, J: 0, K: -0.9753679720836315},
	},
	{
		q: {R: 1, I: 1, J: 1, K: 1}, r: {R: 3},
		w: {R: -8, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1}, r: {R: 3},
		w: {R: -5, I: 0, J: 1, K: 1},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1}, r: {R: 3},
		w: {R: -2, I: 0, J: 0, K: 2},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1}, r: {R: 3},
		w: {R: 0, I: -3, J: -3, K: -3},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1}, r: {R: 3},
		w: {R: 0, I: 0, J: -2, K: -2},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1}, r: {R: 3},
		w: {R: 0, I: 0, J: 0, K: -1},
	},
]

#test
fn testQuatPow(t: &testing::T) {
	for _, test in testsQuatPow {
		mut x := test.q
		x.Pow(&x, &test.r)
		if !equalApprox(x, test.w) {
			t.Errorf("expected {}, found {}, for Pow({})", test.w, x, test.q)
		}
	}
}

struct powRealTest {
	q: Quat
	r: f64
	w: Quat
}

let testsQuatPowReal: []powRealTest = [
	{q: {}, r: 0, w: {R: 1}},
	{
		q: {R: 1, I: 1, J: 1, K: 1}, r: 2,
		w: {R: -2, I: 2, J: 2, K: 2},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1}, r: 2,
		w: {R: -1, I: 0, J: 2, K: 2},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1}, r: 2,
		w: {R: 0, I: 0, J: 0, K: 2},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1}, r: 2,
		w: {R: -3, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1}, r: 2,
		w: {R: -2, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1}, r: 2,
		w: {R: -1, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 1, I: 1, J: 1, K: 1}, r: math::Pi,
		w: {R: -8.728144138959564, I: -0.7527136547040768, J: -0.7527136547040768, K: -0.7527136547040768},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1}, r: math::Pi,
		w: {R: -5.561182514695044, I: 0, J: 0.5556661490713818, K: 0.5556661490713818},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1}, r: math::Pi,
		w: {R: -2.320735561810013, I: 0, J: 0, K: 1.8544983901925216},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1}, r: math::Pi,
		w: {R: 1.2388947209955585, I: -3.162774128856231, J: -3.162774128856231, K: -3.162774128856231},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1}, r: math::Pi,
		w: {R: 0.6552860151073727, I: 0, J: -2.0488506614051922, K: -2.0488506614051922},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1}, r: math::Pi,
		w: {R: 0.22058404074969779, I: 0, J: 0, K: -0.9753679720836315},
	},
	{
		q: {R: 1, I: 1, J: 1, K: 1}, r: 3,
		w: {R: -8, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1}, r: 3,
		w: {R: -5, I: 0, J: 1, K: 1},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1}, r: 3,
		w: {R: -2, I: 0, J: 0, K: 2},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1}, r: 3,
		w: {R: 0, I: -3, J: -3, K: -3},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1}, r: 3,
		w: {R: 0, I: 0, J: -2, K: -2},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1}, r: 3,
		w: {R: 0, I: 0, J: 0, K: -1},
	},
]

#test
fn testQuatPowReal(t: &testing::T) {
	for _, test in testsQuatPowReal {
		mut x := test.q
		x.PowReal(&x, test.r)
		if !equalApprox(x, test.w) {
			t.Errorf("expected {}, found {}, for PowReal({})", test.w, x, test.q)
		}
	}
}

fn equalApprox(a: Quat, b: Quat): bool {
	ret julenum::Close(a.R, b.R) &&
		julenum::Close(a.I, b.I) &&
		julenum::Close(a.J, b.J) &&
		julenum::Close(a.K, b.K)
}