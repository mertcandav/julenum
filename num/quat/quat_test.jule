// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/math"
use "std/testing"

struct quatArithTest {
	x: Quat
	y: Quat
	f: f64

	rAdd:   Quat
	rSub:   Quat
	rMul:   Quat
	rScale: Quat
}

let testsQuatArith: []quatArithTest = [
	{
		x: {1, 1, 1, 1}, y: {1, 1, 1, 1},
		f: 2,
		rAdd: {2, 2, 2, 2},
		rSub: {0, 0, 0, 0},
		rMul: {-2, 2, 2, 2},
		rScale: {2, 2, 2, 2},
	},
	{
		x: {1, 1, 1, 1}, y: {2, -1, 1, -1},
		f: -2,
		rAdd: {3, 0, 2, 0},
		rSub: {-1, 2, 0, 2},
		rMul: {3, -1, 3, 3},
		rScale: {-2, -2, -2, -2},
	},
	{
		x: {1, 2, 3, 4}, y: {4, -3, 2, -1},
		f: 2,
		rAdd: {5, -1, 5, 3},
		rSub: {-3, 5, 1, 5},
		rMul: {8, -6, 4, 28},
		rScale: {2, 4, 6, 8},
	},
	{
		x: {1, 2, 3, 4}, y: {-4, 3, -2, 1},
		f: -2,
		rAdd: {-3, 5, 1, 5},
		rSub: {5, -1, 5, 3},
		rMul: {-8, 6, -4, -28},
		rScale: {-2, -4, -6, -8},
	},
	{
		x: {-4, 3, -2, 1}, y: {1, 2, 3, 4},
		f: 0.5,
		rAdd: {-3, 5, 1, 5},
		rSub: {-5, 1, -5, -3},
		rMul: {-8, -16, -24, -2},
		rScale: {-2, 1.5, -1, 0.5},
	},
]

#test
fn testQuatAdd(t: &testing::T) {
	for _, test in testsQuatArith {
		mut x, y := test.x, test.y
		x.Add(&x, &y)
		if x != test.rAdd {
			t.Errorf("expected {}, found {}, for Add({}, {})", test.rAdd, x, test.x, test.y)
		}
	}
}

#test
fn testQuatSub(t: &testing::T) {
	for _, test in testsQuatArith {
		mut x, y := test.x, test.y
		x.Sub(&x, &y)
		if x != test.rSub {
			t.Errorf("expected {}, found {}, for Sub({}, {})", test.rSub, x, test.x, test.y)
		}
	}
}

#test
fn testQuatMul(t: &testing::T) {
	for _, test in testsQuatArith {
		mut x, y := test.x, test.y
		x.Mul(&x, &y)
		if x != test.rMul {
			t.Errorf("expected {}, found {}, for Mul({}, {})", test.rMul, x, test.x, test.y)
		}
	}
}

#test
fn testQuatScale(t: &testing::T) {
	for _, test in testsQuatArith {
		mut x := test.x
		x.Scale(&x, test.f)
		if x != test.rScale {
			t.Errorf("expected {}, found {}, for Scale({}, {})", test.rScale, x, test.x, test.f)
		}
	}
}

let nan = math::NaN()
let inf = math::Inf(1)

struct testQuatBool {
	q: Quat
	r: bool
}

let testsQuatNaN: []testQuatBool = [
	{q: NaN(), r: true},
	{q: {R: nan, I: nan, J: nan, K: nan}, r: true},
	{q: {R: nan, I: 0, J: 0, K: 0}, r: true},
	{q: {R: 0, I: nan, J: 0, K: 0}, r: true},
	{q: {R: 0, I: 0, J: nan, K: 0}, r: true},
	{q: {R: 0, I: 0, J: 0, K: nan}, r: true},
	{q: {R: inf, I: nan, J: nan, K: nan}, r: false},
	{q: {R: nan, I: inf, J: nan, K: nan}, r: false},
	{q: {R: nan, I: nan, J: inf, K: nan}, r: false},
	{q: {R: nan, I: nan, J: nan, K: inf}, r: false},
	{q: {R: -inf, I: nan, J: nan, K: nan}, r: false},
	{q: {R: nan, I: -inf, J: nan, K: nan}, r: false},
	{q: {R: nan, I: nan, J: -inf, K: nan}, r: false},
	{q: {R: nan, I: nan, J: nan, K: -inf}, r: false},
	{q: {}, r: false},
]

#test
fn testQuatNaN(t: &testing::T) {
	for _, test in testsQuatNaN {
		r := test.q.NaN()
		if r != test.r {
			t.Errorf("expected {}, found {}, for NaN({})", test.r, r, test.q)
		}
	}
}

let testsQuatInf: []testQuatBool = [
	{q: Inf(0), r: true},
	{q: {R: inf, I: inf, J: inf, K: inf}, r: true},
	{q: {R: -inf, I: -inf, J: -inf, K: -inf}, r: true},
	{q: {R: inf, I: nan, J: nan, K: nan}, r: true},
	{q: {R: nan, I: inf, J: nan, K: nan}, r: true},
	{q: {R: nan, I: nan, J: inf, K: nan}, r: true},
	{q: {R: nan, I: nan, J: nan, K: inf}, r: true},
	{q: {R: -inf, I: nan, J: nan, K: nan}, r: true},
	{q: {R: nan, I: -inf, J: nan, K: nan}, r: true},
	{q: {R: nan, I: nan, J: -inf, K: nan}, r: true},
	{q: {R: nan, I: nan, J: nan, K: -inf}, r: true},
	{q: {R: inf}, r: true},
	{q: {I: inf}, r: true},
	{q: {J: inf}, r: true},
	{q: {K: inf}, r: true},
	{q: {R: -inf}, r: true},
	{q: {I: -inf}, r: true},
	{q: {J: -inf}, r: true},
	{q: {K: -inf}, r: true},
	{q: {}, r: false},
]

#test
fn testQuatInf(t: &testing::T) {
	for _, test in testsQuatInf {
		r := test.q.Inf()
		if r != test.r {
			t.Errorf("expected {}, found {}, for Inf({})", test.r, r, test.q)
		}
	}
}