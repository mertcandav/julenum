// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "julenum"
use "std/math"
use "std/math/cmplx"
use "std/testing"

struct quatArithTest {
	x: Quat
	y: Quat
	f: f64

	rAdd:   Quat
	rSub:   Quat
	rMul:   Quat
	rScale: Quat
}

let testsQuatArith: []quatArithTest = [
	{
		x: {1, 1, 1, 1}, y: {1, 1, 1, 1},
		f: 2,
		rAdd: {2, 2, 2, 2},
		rSub: {0, 0, 0, 0},
		rMul: {-2, 2, 2, 2},
		rScale: {2, 2, 2, 2},
	},
	{
		x: {1, 1, 1, 1}, y: {2, -1, 1, -1},
		f: -2,
		rAdd: {3, 0, 2, 0},
		rSub: {-1, 2, 0, 2},
		rMul: {3, -1, 3, 3},
		rScale: {-2, -2, -2, -2},
	},
	{
		x: {1, 2, 3, 4}, y: {4, -3, 2, -1},
		f: 2,
		rAdd: {5, -1, 5, 3},
		rSub: {-3, 5, 1, 5},
		rMul: {8, -6, 4, 28},
		rScale: {2, 4, 6, 8},
	},
	{
		x: {1, 2, 3, 4}, y: {-4, 3, -2, 1},
		f: -2,
		rAdd: {-3, 5, 1, 5},
		rSub: {5, -1, 5, 3},
		rMul: {-8, 6, -4, -28},
		rScale: {-2, -4, -6, -8},
	},
	{
		x: {-4, 3, -2, 1}, y: {1, 2, 3, 4},
		f: 0.5,
		rAdd: {-3, 5, 1, 5},
		rSub: {-5, 1, -5, -3},
		rMul: {-8, -16, -24, -2},
		rScale: {-2, 1.5, -1, 0.5},
	},
]

#test
fn testQuatAdd(t: &testing::T) {
	for _, test in testsQuatArith {
		mut x, y := test.x, test.y
		x.Add(&x, &y)
		if x != test.rAdd {
			t.Errorf("expected {}, found {}, for Add({}, {})", test.rAdd, x, test.x, test.y)
		}
	}
}

#test
fn testQuatSub(t: &testing::T) {
	for _, test in testsQuatArith {
		mut x, y := test.x, test.y
		x.Sub(&x, &y)
		if x != test.rSub {
			t.Errorf("expected {}, found {}, for Sub({}, {})", test.rSub, x, test.x, test.y)
		}
	}
}

#test
fn testQuatMul(t: &testing::T) {
	for _, test in testsQuatArith {
		mut x, y := test.x, test.y
		x.Mul(&x, &y)
		if x != test.rMul {
			t.Errorf("expected {}, found {}, for Mul({}, {})", test.rMul, x, test.x, test.y)
		}
	}
}

#test
fn testQuatScale(t: &testing::T) {
	for _, test in testsQuatArith {
		mut x := test.x
		x.Scale(&x, test.f)
		if x != test.rScale {
			t.Errorf("expected {}, found {}, for Scale({}, {})", test.rScale, x, test.x, test.f)
		}
	}
}

let nan = math::NaN()
let inf = math::Inf(1)

struct testQuatBool {
	q: Quat
	r: bool
}

let testsQuatNaN: []testQuatBool = [
	{q: NaN(), r: true},
	{q: {R: nan, I: nan, J: nan, K: nan}, r: true},
	{q: {R: nan, I: 0, J: 0, K: 0}, r: true},
	{q: {R: 0, I: nan, J: 0, K: 0}, r: true},
	{q: {R: 0, I: 0, J: nan, K: 0}, r: true},
	{q: {R: 0, I: 0, J: 0, K: nan}, r: true},
	{q: {R: inf, I: nan, J: nan, K: nan}, r: false},
	{q: {R: nan, I: inf, J: nan, K: nan}, r: false},
	{q: {R: nan, I: nan, J: inf, K: nan}, r: false},
	{q: {R: nan, I: nan, J: nan, K: inf}, r: false},
	{q: {R: -inf, I: nan, J: nan, K: nan}, r: false},
	{q: {R: nan, I: -inf, J: nan, K: nan}, r: false},
	{q: {R: nan, I: nan, J: -inf, K: nan}, r: false},
	{q: {R: nan, I: nan, J: nan, K: -inf}, r: false},
	{q: {}, r: false},
]

#test
fn testQuatNaN(t: &testing::T) {
	for _, test in testsQuatNaN {
		r := test.q.NaN()
		if r != test.r {
			t.Errorf("expected {}, found {}, for NaN({})", test.r, r, test.q)
		}
	}
}

let testsQuatInf: []testQuatBool = [
	{q: Inf(0), r: true},
	{q: {R: inf, I: inf, J: inf, K: inf}, r: true},
	{q: {R: -inf, I: -inf, J: -inf, K: -inf}, r: true},
	{q: {R: inf, I: nan, J: nan, K: nan}, r: true},
	{q: {R: nan, I: inf, J: nan, K: nan}, r: true},
	{q: {R: nan, I: nan, J: inf, K: nan}, r: true},
	{q: {R: nan, I: nan, J: nan, K: inf}, r: true},
	{q: {R: -inf, I: nan, J: nan, K: nan}, r: true},
	{q: {R: nan, I: -inf, J: nan, K: nan}, r: true},
	{q: {R: nan, I: nan, J: -inf, K: nan}, r: true},
	{q: {R: nan, I: nan, J: nan, K: -inf}, r: true},
	{q: {R: inf}, r: true},
	{q: {I: inf}, r: true},
	{q: {J: inf}, r: true},
	{q: {K: inf}, r: true},
	{q: {R: -inf}, r: true},
	{q: {I: -inf}, r: true},
	{q: {J: -inf}, r: true},
	{q: {K: -inf}, r: true},
	{q: {}, r: false},
]

#test
fn testQuatInf(t: &testing::T) {
	for _, test in testsQuatInf {
		r := test.q.Inf()
		if r != test.r {
			t.Errorf("expected {}, found {}, for Inf({})", test.r, r, test.q)
		}
	}
}

struct testQuatF64 {
	q: Quat
	r: f64
}

let testsQuatAbs: []testQuatF64 = [
	{q: {}, r: 0},
	{q: NaN(), r: nan},
	{q: Inf(0), r: inf},
	{q: {R: 1, I: 1, J: 1, K: 1}, r: 2},
	{q: {R: -1, I: 1, J: -1, K: 1}, r: 2},
	{q: {R: 1, I: 2, J: 3, K: 4}, r: math::Sqrt(1 + 4 + 9 + 16)},
	{q: {R: -1, I: -2, J: -3, K: -4}, r: math::Sqrt(1 + 4 + 9 + 16)},
]

#test
fn testQuatAbs(t: &testing::T) {
	for _, test in testsQuatAbs {
		r := test.q.Abs()
		if math::IsNaN(test.r) {
			if !math::IsNaN(r) {
				t.Errorf("expected {}, found {}, for Abs({})", test.r, r, test.q)
			}
			continue
		}
		if r != test.r {
			t.Errorf("expected {}, found {}, for Inf({})", test.r, r, test.q)
		}
	}
}

// r = want NaN
let testsQuatInv: []testQuatBool = [
	{q: {R: 1, I: 1, J: 1, K: 1}},
	{q: {R: 3, I: -1, J: 5, K: -40}},
	{q: {R: 1e6, I: -1e5, J: 4, K: -10}},
	{q: {R: 0, I: 1, J: 1, K: 1}},
	{q: {R: 1, I: 0, J: 1, K: 1}},
	{q: {R: 1, I: 1, J: 0, K: 1}},
	{q: {R: 1, I: 1, J: 1, K: 0}},
	{q: {}, r: true},
]

#test
fn testQuatInv(t: &testing::T) {
	for _, test in testsQuatInv {
		mut r := test.q
		r.Inv(&r)
		r.Mul(&r, &test.q)
		if test.r { // want NaN
			if !r.NaN() {
				t.Errorf("expected NaN, found {}, for Inv({})", r, test.q)
			}
			continue
		}
		if !julenum::Close(r.R, 1) || !julenum::Close(r.Abs(), 1) {
			t.Errorf("expected R=1, found {}, for Inv({})", r, test.q)
		}
	}
}

struct testQuatQuat {
	q: Quat
	r: Quat
}

let testsQuatExp: []testQuatQuat = [
	{q: {}, r: {R: 1}},
	// Expected velues below are from pyquaternion.
	{
		q: {R: 1, I: 1, J: 1, K: 1},
		r: {R: -0.43643792124786496, I: 1.549040352371697, J: 1.549040352371697, K: 1.549040352371697},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1},
		r: {R: 0.42389891174348104, I: 0, J: 1.8986002490721081, K: 1.8986002490721081},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1},
		r: {R: 1.4686939399158851, I: 0, J: 0, K: 2.2873552871788423},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1},
		r: {R: -0.16055653857469052, I: 0.569860099182514, J: 0.569860099182514, K: 0.569860099182514},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1},
		r: {R: 0.15594369476537437, I: 0, J: 0.6984559986366083, K: 0.6984559986366083},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1},
		r: {R: 0.5403023058681398, I: 0, J: 0, K: 0.8414709848078965},
	},
]

#test
fn testQuatExp(t: &testing::T) {
	for _, test in testsQuatExp {
		mut x := test.q
		x.Exp(&x)
		if !equalApprox(x, test.r) {
			t.Errorf("expected {}, found {}, for Exp({})", test.r, x, test.q)
		}
	}
}

let testsQuatLog: []testQuatQuat = [
	{q: {}, r: {R: -inf}},
	// Expected velues below are from pyquaternion.
	{
		q: {R: 1, I: 1, J: 1, K: 1},
		r: {R: 0.6931471805599453, I: 0.6045997880780728, J: 0.6045997880780728, K: 0.6045997880780728},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1},
		r: {R: 0.5493061443340548, I: 0, J: 0.6755108588560398, K: 0.6755108588560398},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1},
		r: {R: 0.3465735902799727, I: 0, J: 0, K: 0.7853981633974484},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1},
		r: {R: 0.5493061443340548, I: 0.906899682117109, J: 0.906899682117109, K: 0.906899682117109},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1},
		r: {R: 0.3465735902799727, I: 0, J: 1.1107207345395915, K: 1.1107207345395915},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1},
		r: {R: 0, I: 0, J: 0, K: 1.5707963267948966},
	},
]

#test
fn testQuatLog(t: &testing::T) {
	for _, test in testsQuatLog {
		mut x := test.q
		x.Log(&x)
		if !equalApprox(x, test.r) {
			t.Errorf("expected {}, found {}, for Log({})", test.r, x, test.q)
		}
	}
}

struct quatPowTest {
	q: Quat
	r: Quat
	w: Quat
}

let testsQuatPow: []quatPowTest = [
	{q: {}, r: {}, w: {R: 1}},
	// Expected velues below are from pyquaternion.
	// pyquaternion does not support quaternion powers.
	{
		q: {R: 1, I: 1, J: 1, K: 1}, r: {R: 2},
		w: {R: -2, I: 2, J: 2, K: 2},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1}, r: {R: 2},
		w: {R: -1, I: 0, J: 2, K: 2},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1}, r: {R: 2},
		w: {R: 0, I: 0, J: 0, K: 2},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1}, r: {R: 2},
		w: {R: -3, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1}, r: {R: 2},
		w: {R: -2, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1}, r: {R: 2},
		w: {R: -1, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 1, I: 1, J: 1, K: 1}, r: {R: math::Pi},
		w: {R: -8.728144138959564, I: -0.7527136547040768, J: -0.7527136547040768, K: -0.7527136547040768},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1}, r: {R: math::Pi},
		w: {R: -5.561182514695044, I: 0, J: 0.5556661490713818, K: 0.5556661490713818},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1}, r: {R: math::Pi},
		w: {R: -2.320735561810013, I: 0, J: 0, K: 1.8544983901925216},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1}, r: {R: math::Pi},
		w: {R: 1.2388947209955585, I: -3.162774128856231, J: -3.162774128856231, K: -3.162774128856231},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1}, r: {R: math::Pi},
		w: {R: 0.6552860151073727, I: 0, J: -2.0488506614051922, K: -2.0488506614051922},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1}, r: {R: math::Pi},
		w: {R: 0.22058404074969779, I: 0, J: 0, K: -0.9753679720836315},
	},
	{
		q: {R: 1, I: 1, J: 1, K: 1}, r: {R: 3},
		w: {R: -8, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1}, r: {R: 3},
		w: {R: -5, I: 0, J: 1, K: 1},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1}, r: {R: 3},
		w: {R: -2, I: 0, J: 0, K: 2},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1}, r: {R: 3},
		w: {R: 0, I: -3, J: -3, K: -3},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1}, r: {R: 3},
		w: {R: 0, I: 0, J: -2, K: -2},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1}, r: {R: 3},
		w: {R: 0, I: 0, J: 0, K: -1},
	},
]

#test
fn testQuatPow(t: &testing::T) {
	for _, test in testsQuatPow {
		mut x := test.q
		x.Pow(&x, &test.r)
		if !equalApprox(x, test.w) {
			t.Errorf("expected {}, found {}, for Pow({}, {})", test.w, x, test.q, test.r)
		}
	}
}

struct powRealTest {
	q: Quat
	r: f64
	w: Quat
}

let testsQuatPowReal: []powRealTest = [
	{q: {}, r: 0, w: {R: 1}},
	{
		q: {R: 1, I: 1, J: 1, K: 1}, r: 2,
		w: {R: -2, I: 2, J: 2, K: 2},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1}, r: 2,
		w: {R: -1, I: 0, J: 2, K: 2},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1}, r: 2,
		w: {R: 0, I: 0, J: 0, K: 2},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1}, r: 2,
		w: {R: -3, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1}, r: 2,
		w: {R: -2, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1}, r: 2,
		w: {R: -1, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 1, I: 1, J: 1, K: 1}, r: math::Pi,
		w: {R: -8.728144138959564, I: -0.7527136547040768, J: -0.7527136547040768, K: -0.7527136547040768},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1}, r: math::Pi,
		w: {R: -5.561182514695044, I: 0, J: 0.5556661490713818, K: 0.5556661490713818},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1}, r: math::Pi,
		w: {R: -2.320735561810013, I: 0, J: 0, K: 1.8544983901925216},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1}, r: math::Pi,
		w: {R: 1.2388947209955585, I: -3.162774128856231, J: -3.162774128856231, K: -3.162774128856231},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1}, r: math::Pi,
		w: {R: 0.6552860151073727, I: 0, J: -2.0488506614051922, K: -2.0488506614051922},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1}, r: math::Pi,
		w: {R: 0.22058404074969779, I: 0, J: 0, K: -0.9753679720836315},
	},
	{
		q: {R: 1, I: 1, J: 1, K: 1}, r: 3,
		w: {R: -8, I: 0, J: 0, K: 0},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1}, r: 3,
		w: {R: -5, I: 0, J: 1, K: 1},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1}, r: 3,
		w: {R: -2, I: 0, J: 0, K: 2},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1}, r: 3,
		w: {R: 0, I: -3, J: -3, K: -3},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1}, r: 3,
		w: {R: 0, I: 0, J: -2, K: -2},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1}, r: 3,
		w: {R: 0, I: 0, J: 0, K: -1},
	},
]

#test
fn testQuatPowReal(t: &testing::T) {
	for _, test in testsQuatPowReal {
		mut x := test.q
		x.PowReal(&x, test.r)
		if !equalApprox(x, test.w) {
			t.Errorf("expected {}, found {}, for PowReal({}, {})", test.w, x, test.q, test.r)
		}
	}
}

let testsQuatSqrt: []testQuatQuat = [
	{q: {}, r: {}},
	// Expected velues below are from pyquaternion.
	{
		q: {R: 1, I: 1, J: 1, K: 1},
		r: {R: 1.2247448713915892, I: 0.4082482904638631, J: 0.4082482904638631, K: 0.4082482904638631},
	},
	{
		q: {R: 1, I: 0, J: 1, K: 1},
		r: {R: 1.1687708944803676, I: 0, J: 0.42779983858367593, K: 0.42779983858367593},
	},
	{
		q: {R: 1, I: 0, J: 0, K: 1},
		r: {R: 1.0986841134678098, I: 0, J: 0, K: 0.45508986056222733},
	},
	{
		q: {R: 0, I: 1, J: 1, K: 1},
		r: {R: 0.9306048591020996, I: 0.5372849659117709, J: 0.5372849659117709, K: 0.5372849659117709},
	},
	{
		q: {R: 0, I: 0, J: 1, K: 1},
		r: {R: 0.8408964152537146, I: 0, J: 0.5946035575013604, K: 0.5946035575013604},
	},
	{
		q: {R: 0, I: 0, J: 0, K: 1},
		r: {R: 0.7071067811865476, I: 0, J: 0, K: 0.7071067811865475},
	},
]

#test
fn testQuatSqrt(t: &testing::T) {
	for _, test in testsQuatSqrt {
		mut x := test.q
		x.Sqrt(&x)
		if !equalApprox(x, test.r) {
			t.Errorf("expected {}, found {}, for Sqrt({})", test.r, x, test.q)
		}
	}
}

// Including exercises from Real Quaternionic Calculus Handbook doi:10.1007/978-3-0348-0622-0
// Ex 6.159 (a) and (b).
let testsQuatSin: []testQuatQuat = [
	{q: {}, r: {}},
	{q: {R: math::Pi / 2}, r: {R: 1}},
	{q: {I: math::Pi / 2}, r: {I: cmplx::Sin(cmplx::New(0, math::Pi/2)).Imag()}},
	{q: {J: math::Pi / 2}, r: {J: cmplx::Sin(cmplx::New(0, math::Pi/2)).Imag()}},
	{q: {K: math::Pi / 2}, r: {K: cmplx::Sin(cmplx::New(0, math::Pi/2)).Imag()}},
	{
		q: {R: 1, I: 1, J: 1, K: 1}, r: fn(): Quat {
			p := math::Cos(1) * math::Sinh(math::Sqrt(3)) / math::Sqrt(3)
			// An error exists in the book's given solution for the real part.
			ret {R: math::Sin(1) * math::Cosh(math::Sqrt(3)), I: p, J: p, K: p}
		}(),
	},
	{
		q: {I: -2, J: 1}, r: fn(): Quat {
			s := math::Sinh(math::Sqrt(5)) / math::Sqrt(5)
			ret Quat{I: -2 * s, J: s}
		}(),
	},
]

#test
fn testQuatSin(t: &testing::T) {
	for _, test in testsQuatSin {
		mut x := test.q
		x.Sin(&x)
		if !equalApprox(x, test.r) {
			t.Errorf("expected {}, found {}, for Sin({})", test.r, x, test.q)
		}
	}
}

let testsQuatSinh: []testQuatQuat = [
	{q: {}, r: {}},
	{q: {R: math::Pi / 2}, r: {R: math::Sinh(math::Pi / 2)}},
	{q: {I: math::Pi / 2}, r: {I: cmplx::Sinh(cmplx::New(0, math::Pi/2)).Imag()}},
	{q: {J: math::Pi / 2}, r: {J: cmplx::Sinh(cmplx::New(0, math::Pi/2)).Imag()}},
	{q: {K: math::Pi / 2}, r: {K: cmplx::Sinh(cmplx::New(0, math::Pi/2)).Imag()}},
	{
		q: {R: 1, I: -1, J: -1}, r: fn(): Quat {
			// This was based on the example on p118, but it too has an error.
			mut q := Quat{R: 1, I: -1, J: -1}
			mut exp := q
			exp.Exp(&exp)
			q.Scale(&q, -1)
			q.Exp(&q)
			q.Sub(&exp, &q)
			q.Scale(&q, 0.5)
			ret q
		}(),
	},
	{
		q: {1, 1, 1, 1}, r: fn(): Quat {
			mut q := Quat{1, 1, 1, 1}
			mut exp := q
			exp.Exp(&exp)
			q.Scale(&q, -1)
			q.Exp(&q)
			q.Sub(&exp, &q)
			q.Scale(&q, 0.5)
			ret q
		}(),
	},
	{q: asinh({1, 1, 1, 1}), r: {1, 1, 1, 1}},
	{
		q: asinh({1, 1, 1, 1}), r: fn(): Quat {
			mut q := asinh({1, 1, 1, 1})
			mut exp := q
			exp.Exp(&exp)
			q.Scale(&q, -1)
			q.Exp(&q)
			q.Sub(&exp, &q)
			q.Scale(&q, 0.5)
			ret q
		}(),
	},
	{q: {R: math::Inf(1)}, r: {R: math::Inf(1)}},
	{q: {R: math::Inf(1), I: math::Pi / 2}, r: {R: math::Inf(1), I: math::Inf(1)}},
	{q: {R: math::Inf(1), I: math::Pi}, r: {R: math::Inf(-1), I: math::Inf(1)}},
	{q: {R: math::Inf(1), I: 3 * math::Pi / 2}, r: {R: math::Inf(-1), I: math::Inf(-1)}},
	{q: {R: math::Inf(1), I: 2 * math::Pi}, r: {R: math::Inf(1), I: math::Inf(-1)}},
]

#test
fn testQuatSinh(t: &testing::T) {
	for _, test in testsQuatSinh {
		mut x := test.q
		x.Sinh(&x)
		if !sameApprox(x, test.r) {
			t.Errorf("expected {}, found {}, for Sinh({})", test.r, x, test.q)
		}
	}
}

// Including example from Real Quaternionic Calculus Handbook doi:10.1007/978-3-0348-0622-0 p108.
let testsQuatCos: []testQuatQuat = [
	{q: {}, r: {R: 1}},
	{q: {R: math::Pi / 2}, r: {R: 0}},
	{q: {I: math::Pi / 2}, r: {R: cmplx::Cos(cmplx::New(0, math::Pi/2)).Real()}},
	{q: {J: math::Pi / 2}, r: {R: cmplx::Cos(cmplx::New(0, math::Pi/2)).Real()}},
	{q: {K: math::Pi / 2}, r: {R: cmplx::Cos(cmplx::New(0, math::Pi/2)).Real()}},
	{q: {R: 1, I: 1, J: 1, K: 1}, r: fn(): Quat {
			p := math::Sin(1) * math::Sinh(math::Sqrt(3)) / math::Sqrt(3)
			ret Quat{R: math::Cos(1) * math::Cosh(math::Sqrt(3)), I: -p, J: -p, K: -p}
		}()},
]

#test
fn testQuatCos(t: &testing::T) {
	for _, test in testsQuatCos {
		mut x := test.q
		x.Cos(&x)
		if !equalApprox(x, test.r) {
			t.Errorf("expected {}, found {}, for Cos({})", test.r, x, test.q)
		}
	}
}

let testsQuatCosh: []testQuatQuat = [
	{q: {}, r: {R: 1}},
	{q: {R: math::Pi / 2}, r: {R: math::Cosh(math::Pi / 2)}},
	{q: {I: math::Pi / 2}, r: {I: cmplx::Cosh(cmplx::New(0, math::Pi/2)).Imag()}},
	{q: {J: math::Pi / 2}, r: {J: cmplx::Cosh(cmplx::New(0, math::Pi/2)).Imag()}},
	{q: {K: math::Pi / 2}, r: {K: cmplx::Cosh(cmplx::New(0, math::Pi/2)).Imag()}},
	{q: {R: 1, I: -1, J: -1}, r: fn(): Quat {
			mut q := Quat{R: 1, I: -1, J: -1}
			mut t := q
			q.Scale(&q, -1)
			q.Exp(&q)
			t.Exp(&t)
			q.Add(&q, &t)
			q.Scale(&q, 0.5)
			ret q
		}()},
	{q: {1, 1, 1, 1}, r: fn(): Quat {
			mut q := Quat{1, 1, 1, 1}
			mut t := q
			q.Scale(&q, -1)
			q.Exp(&q)
			t.Exp(&t)
			q.Add(&q, &t)
			q.Scale(&q, 0.5)
			ret q
		}()},
	{q: {R: math::Inf(1)}, r: {R: math::Inf(1)}},
	{q: {R: math::Inf(1), I: math::Pi / 2}, r: {R: math::Inf(1), I: math::Inf(1)}},
	{q: {R: math::Inf(1), I: math::Pi}, r: {R: math::Inf(-1), I: math::Inf(1)}},
	{q: {R: math::Inf(1), I: 3 * math::Pi / 2}, r: {R: math::Inf(-1), I: math::Inf(-1)}},
	{q: {R: math::Inf(1), I: 2 * math::Pi}, r: {R: math::Inf(1), I: math::Inf(-1)}},
]

#test
fn testQuatCosh(t: &testing::T) {
	for _, test in testsQuatCosh {
		mut x := test.q
		x.Cosh(&x)
		if !sameApprox(x, test.r) {
			t.Errorf("expected {}, found {}, for Cosh({})", test.r, x, test.q)
		}
	}
}

let testsQuatTan: []testQuatQuat = [
	{q: {}, r: {}},
	{q: {R: math::Pi / 4}, r: {R: math::Tan(math::Pi / 4)}},
	{q: {I: math::Pi / 4}, r: {I: cmplx::Tan(cmplx::New(0, math::Pi/4)).Imag()}},
	{q: {J: math::Pi / 4}, r: {J: cmplx::Tan(cmplx::New(0, math::Pi/4)).Imag()}},
	{q: {K: math::Pi / 4}, r: {K: cmplx::Tan(cmplx::New(0, math::Pi/4)).Imag()}},

	// From exercise from Real Numberernionic Calculus Handbook doi:10.1007/978-3-0348-0622-0
	{q: {I: 1}, r: mul(sin({I: 1}), inv(cos({I: 1})))},
	{q: {1, 1, 1, 1}, r: mul(sin({1, 1, 1, 1}), inv(cos({1, 1, 1, 1})))},
]

#test
fn testQuatTan(t: &testing::T) {
	for _, test in testsQuatTan {
		mut x := test.q
		x.Tan(&x)
		if !equalApprox(x, test.r) {
			t.Errorf("expected {}, found {}, for Tan({})", test.r, x, test.q)
		}
	}
}

let testsQuatTanh: []testQuatQuat = [
	{q: {}, r: {}},
	{q: {R: math::Pi / 4}, r: {R: math::Tanh(math::Pi / 4)}},
	{q: {I: math::Pi / 4}, r: {I: cmplx::Tanh(cmplx::New(0, math::Pi/4)).Imag()}},
	{q: {J: math::Pi / 4}, r: {J: cmplx::Tanh(cmplx::New(0, math::Pi/4)).Imag()}},
	{q: {K: math::Pi / 4}, r: {K: cmplx::Tanh(cmplx::New(0, math::Pi/4)).Imag()}},
	{q: {I: 1}, r: mul(sinh({I: 1}), inv(cosh({I: 1})))},
	{q: {1, 1, 1, 1}, r: mul(sinh({1, 1, 1, 1}), inv(cosh({1, 1, 1, 1})))},
	{q: {R: math::Inf(1)}, r: {R: 1}},
	{q: {R: math::Inf(1), I: math::Pi / 4}, r: {R: 1, I: 0 * math::Sin(math::Pi/2)}},
	{q: {R: math::Inf(1), I: math::Pi / 2}, r: {R: 1, I: 0 * math::Sin(math::Pi)}},
	{q: {R: math::Inf(1), I: 3 * math::Pi / 4}, r: {R: 1, I: 0 * math::Sin(3*math::Pi/2)}},
	{q: {R: math::Inf(1), I: math::Pi}, r: {R: 1, I: 0 * math::Sin(2*math::Pi)}},
]

#test
fn testQuatTanh(t: &testing::T) {
	for _, test in testsQuatTanh {
		mut x := test.q
		x.Tanh(&x)
		if !sameApprox(x, test.r) {
			t.Errorf("expected {}, found {}, for Tanh({})", test.r, x, test.q)
		}
	}
}

let testsQuatAsin: []testQuatQuat = [
	{q: {}, r: {}},
	{q: {R: 1}, r: {R: math::Pi / 2}},
	{q: {I: 1}, r: {I: cmplx::Asinh(cmplx::New(1, 0)).Real()}},
	{q: {J: 1}, r: {J: cmplx::Asinh(cmplx::New(1, 0)).Real()}},
	{q: {K: 1}, r: {K: cmplx::Asinh(cmplx::New(1, 0)).Real()}},
	{q: sin({1, 1, 1, 1}), r: {1, 1, 1, 1}},
]

#test
fn testQuatAsin(t: &testing::T) {
	for _, test in testsQuatAsin {
		mut x := test.q
		x.Asin(&x)
		if !equalApprox(x, test.r) {
			t.Errorf("expected {}, found {}, for Asin({})", test.r, x, test.q)
		}
	}
}

let testsQuatAsinh: []testQuatQuat = [
	{q: {}, r: {}},
	{q: {R: 1}, r: {R: math::Asinh(1)}},
	{q: {I: 1}, r: {I: math::Pi / 2}},
	{q: {J: 1}, r: {J: math::Pi / 2}},
	{q: {K: 1}, r: {K: math::Pi / 2}},
	{q: {1, 1, 1, 1}, r: fn(): Quat {
			mut q := Quat{1, 1, 1, 1}
			mut p := Quat{R: 1}
			q.Mul(&q, &q)
			q.Add(&q, &p)
			q.Sqrt(&q)
			p = {1, 1, 1, 1}
			q.Add(&q, &p)
			q.Log(&q)
			ret q
		}()},
	{q: sinh({R: 1}), r: {R: 1}},
	{q: sinh({I: 1}), r: {I: 1}},
	{q: sinh({I: 1, J: 1}), r: {I: 1, J: 1}},
	{q: sinh({R: 1, I: 1, J: 1}), r: {R: 1, I: 1, J: 1}},
	{q: sinh({1, 1, 1, 1}), r: fn(): Quat {
			// The following fails:
			// {q: sinh({1, 1, 1, 1}), r: {1, 1, 1, 1}},
			// but this passes...
			mut p := Quat{R: 1}
			mut q := sinh({1, 1, 1, 1})
			q.Mul(&q, &q)
			q.Add(&q, &p)
			q.Sqrt(&q)
			p = sinh({1, 1, 1, 1})
			q.Add(&q, &p)
			q.Log(&q)
			ret q
		}()},
	// And see the Sinh tests that do the reciprocal operation.
]

#test
fn testQuatAsinh(t: &testing::T) {
	for _, test in testsQuatAsinh {
		mut x := test.q
		x.Asinh(&x)
		if !equalApprox(x, test.r) {
			t.Errorf("expected {}, found {}, for Asinh({})", test.r, x, test.q)
		}
	}
}

let testsQuatAcos: []testQuatQuat = [
	{q: {}, r: {R: math::Pi / 2}},
	{q: {R: 1}, r: {R: 0}},
	{q: {I: 1}, r: {R: cmplx::Acos(cmplx::New(0, 1)).Real(), I: cmplx::Acos(cmplx::New(0, 1)).Imag()}},
	{q: {J: 1}, r: {R: cmplx::Acos(cmplx::New(0, 1)).Real(), J: cmplx::Acos(cmplx::New(0, 1)).Imag()}},
	{q: {K: 1}, r: {R: cmplx::Acos(cmplx::New(0, 1)).Real(), K: cmplx::Acos(cmplx::New(0, 1)).Imag()}},
	{q: cos({1, 1, 1, 1}), r: {1, 1, 1, 1}},
]

#test
fn testQuatAcos(t: &testing::T) {
	for _, test in testsQuatAcos {
		mut x := test.q
		x.Acos(&x)
		if !equalApprox(x, test.r) {
			t.Errorf("expected {}, found {}, for Acos({})", test.r, x, test.q)
		}
	}
}

let testsQuatAcosh: []testQuatQuat = [
	{q: {}, r: {R: math::Pi / 2}},
	{q: {R: 1}, r: {R: math::Acosh(1)}},
	{q: {I: 1}, r: {R: cmplx::Acosh(cmplx::New(0, 1)).Real(), I: cmplx::Acosh(cmplx::New(0, 1)).Imag()}},
	{q: {J: 1}, r: {R: cmplx::Acosh(cmplx::New(0, 1)).Real(), J: cmplx::Acosh(cmplx::New(0, 1)).Imag()}},
	{q: {K: 1}, r: {R: cmplx::Acosh(cmplx::New(0, 1)).Real(), K: cmplx::Acosh(cmplx::New(0, 1)).Imag()}},
	{q: cosh({1, 1, 1, 1}), r: {1, 1, 1, 1}},
	{
		q: {1, 1, 1, 1}, r: fn(): Quat {
			mut q := Quat{1, 1, 1, 1}
			mut p := Quat{R: 1}
			q.Mul(&q, &q)
			q.Sub(&q, &p)
			q.Sqrt(&q)
			p = Quat{1, 1, 1, 1}
			p.Add(&p, &q)
			p.Log(&p)
			ret p
		}(),
	},
]

#test
fn testQuatAcosh(t: &testing::T) {
	for _, test in testsQuatAcosh {
		mut x := test.q
		x.Acosh(&x)
		if !equalApprox(x, test.r) {
			t.Errorf("expected {}, found {}, for Acosh({})", test.r, x, test.q)
		}
	}
}

fn equalApprox(a: Quat, b: Quat): bool {
	ret julenum::Close(a.R, b.R) &&
		julenum::Close(a.I, b.I) &&
		julenum::Close(a.J, b.J) &&
		julenum::Close(a.K, b.K)
}

fn sameApprox(a: Quat, b: Quat): bool {
	match {
	| a.R == 0 && b.R == 0:
		ret math::Signbit(a.R) == math::Signbit(b.R)
	| a.I == 0 && b.I == 0:
		ret math::Signbit(a.I) == math::Signbit(b.I)
	| a.J == 0 && b.J == 0:
		ret math::Signbit(a.J) == math::Signbit(b.J)
	| a.K == 0 && b.K == 0:
		ret math::Signbit(a.K) == math::Signbit(b.K)
	}
	ret (sameFloat(a.R, b.R) || julenum::Close(a.R, b.R)) &&
		(sameFloat(a.I, b.I) || julenum::Close(a.I, b.I)) &&
		(sameFloat(a.J, b.J) || julenum::Close(a.J, b.J)) &&
		(sameFloat(a.K, b.K) || julenum::Close(a.K, b.K))
}

fn sameFloat(a: f64, b: f64): bool {
	ret a == b || (math::IsNaN(a) && math::IsNaN(b))
}

fn asinh(mut q: Quat): Quat {
	q.Asinh(&q)
	ret q
}

fn sinh(mut q: Quat): Quat {
	q.Sinh(&q)
	ret q
}

fn sin(mut q: Quat): Quat {
	q.Sin(&q)
	ret q
}

fn cos(mut q: Quat): Quat {
	q.Cos(&q)
	ret q
}

fn cosh(mut q: Quat): Quat {
	q.Cosh(&q)
	ret q
}

fn tan(mut q: Quat): Quat {
	q.Tan(&q)
	ret q
}

fn inv(mut q: Quat): Quat {
	q.Inv(&q)
	ret q
}

fn mul(mut x: Quat, y: Quat): Quat {
	x.Mul(&x, &y)
	ret x
}