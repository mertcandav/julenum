// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/math"

// Quaternion with floating-point precision.
struct Quat {
	R: f64
	I: f64
	J: f64
	K: f64
}

impl Quat {
	// Reports whether any field of quaternion is NaN and none are an infinity.
	fn NaN(*self): bool {
		if math::IsInf(self.R, 0) || math::IsInf(self.I, 0) ||
			math::IsInf(self.J, 0) || math::IsInf(self.K, 0) {
			ret false
		}
		ret math::IsNaN(self.R) || math::IsNaN(self.I) ||
			math::IsNaN(self.J) || math::IsNaN(self.K)
	}

	// Reports whether any of field of quaternion is ±infinity.
	fn Inf(*self): bool {
		ret math::IsInf(self.R, 0) || math::IsInf(self.I, 0) ||
			math::IsInf(self.J, 0) || math::IsInf(self.K, 0)
	}

	// Reports whether all fields of quaternion is zero.
	fn Zero(*self): bool {
		ret self.R == 0 && self.I == 0 && self.J == 0 && self.K == 0
	}

	// Sets self to the sum of x+y.
	fn Add(mut *self, &x: *Quat, &y: *Quat) {
		self.R, self.I, self.J, self.K = x.R+y.R, x.I+y.I, x.J+y.J, x.K+y.K
	}

	// Sets self to the difference x-y.
	fn Sub(mut *self, &x: *Quat, &y: *Quat) {
		self.R, self.I, self.J, self.K = x.R-y.R, x.I-y.I, x.J-y.J, x.K-y.K
	}

	// Sets self to the Hamiltonian product x*y.
	fn Mul(mut *self, &x: *Quat, &y: *Quat) {
		r := x.R*y.R - x.I*y.I - x.J*y.J - x.K*y.K
		i := x.R*y.I + x.I*y.R + x.J*y.K - x.K*y.J
		j := x.R*y.J - x.I*y.K + x.J*y.R + x.K*y.I
		k := x.R*y.K + x.I*y.J - x.J*y.I + x.K*y.R
		self.R, self.I, self.J, self.K = r, i, j, k
	}

	// Sets self to the product x*k.
	fn Scale(mut *self, &x: *Quat, k: f64) {
		self.R, self.I, self.J, self.K = x.R*k, x.I*k, x.J*k, x.K*k
	}

	// Sets self to the quaternion conjugate of x.
	fn Conj(mut *self, &x: *Quat) {
		self.R, self.I, self.J, self.K = x.R, -x.I, -x.J, -x.K
	}

	// Sets self to the quaternion inverse of x.
	fn Inv(mut *self, &x: *Quat) {
		if x.Inf() {
			self.R, self.I, self.J, self.K = 0, 0, 0, 0
			ret
		}
		a := x.Abs()
		self.Conj(x)
		self.Scale(self, 1/(a*a))
	}

	// Sets self to the product e**x, the base-e exponential of x.
	fn Exp(mut *self, &x: *Quat) {
		w, uv := split(x)
		if uv.Zero() {
			lift(self, math::Exp(w))
			ret
		}
		v := uv.Abs()
		e := math::Exp(w)
		s, c := math::Sincos(v)
		self.Scale(&uv, e*s/v)
		join(self, e*c)
	}

	// Returns the absolute value (also called the modulus) of quaternion.
	//
	// Special cases:
	//	Abs() = +Inf, if quaternion is ±Inf.
	//	Abs() = NaN, if quaternion is NaN
	fn Abs(*self): f64 {
		// Special cases.
		match {
		| self.Inf():
			ret math::Inf(1)
		| self.NaN():
			ret math::NaN()
		}

		mut r, mut i, mut j, mut k := self.R, self.I, self.J, self.K
		if r < 0 {
			r = -r
		}
		if i < 0 {
			i = -i
		}
		if j < 0 {
			j = -j
		}
		if k < 0 {
			k = -k
		}
		if r < i {
			r, i = i, r
		}
		if r < j {
			r, j = j, r
		}
		if r < k {
			r, k = k, r
		}
		if r == 0 {
			ret 0
		}
		i /= r
		j /= r
		k /= r
		ret r * math::Sqrt(1+i*i+j*j+k*k)
	}
}

// Returns a quaternion NaN.
fn NaN(): Quat {
	nan := math::NaN()
	ret Quat{nan, nan, nan, nan}
}

// Returns a quaternion ±infinity by sign.
fn Inf(sign: int): Quat {
	inf := math::Inf(sign)
	ret Quat{inf, inf, inf, inf}
}

fn lift(mut &q: *Quat, v: f64) {
	q.R, q.I, q.J, q.K = v, 0, 0, 0
}

fn split(&q: *Quat): (f64, Quat) {
	ret q.R, Quat{0, q.I, q.J, q.K}
}

fn join(mut &uv: *Quat, w: f64) {
	uv.R = w
}