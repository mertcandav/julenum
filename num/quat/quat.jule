// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/math"

// Quaternion with floating-point precision.
struct Quat {
	R: f64
	I: f64
	J: f64
	K: f64
}

impl Quat {
	// Reports whether any field of quaternion is NaN and none are an infinity.
	fn NaN(*self): bool {
		if math::IsInf(self.R, 0) || math::IsInf(self.I, 0) ||
			math::IsInf(self.J, 0) || math::IsInf(self.K, 0) {
			ret false
		}
		ret math::IsNaN(self.R) || math::IsNaN(self.I) ||
			math::IsNaN(self.J) || math::IsNaN(self.K)
	}

	// Reports whether any of field of quaternion is ±infinity.
	fn Inf(*self): bool {
		ret math::IsInf(self.R, 0) || math::IsInf(self.I, 0) ||
			math::IsInf(self.J, 0) || math::IsInf(self.K, 0)
	}

	// Sets self to the sum of x+y.
	fn Add(mut *self, &x: *Quat, &y: *Quat) {
		self.R, self.I, self.J, self.K = x.R+y.R, x.I+y.I, x.J+y.J, x.K+y.K
	}

	// Sets self to the difference x-y.
	fn Sub(mut *self, &x: *Quat, &y: *Quat) {
		self.R, self.I, self.J, self.K = x.R-y.R, x.I-y.I, x.J-y.J, x.K-y.K
	}

	// Sets self to the Hamiltonian product x*y.
	fn Mul(mut *self, &x: *Quat, &y: *Quat) {
		r := x.R*y.R - x.I*y.I - x.J*y.J - x.K*y.K
		i := x.R*y.I + x.I*y.R + x.J*y.K - x.K*y.J
		j := x.R*y.J - x.I*y.K + x.J*y.R + x.K*y.I
		k := x.R*y.K + x.I*y.J - x.J*y.I + x.K*y.R
		self.R, self.I, self.J, self.K = r, i, j, k
	}
}

// Returns a quaternion NaN.
fn NaN(): Quat {
	nan := math::NaN()
	ret Quat{nan, nan, nan, nan}
}

// Returns a quaternion ±infinity by sign.
fn Inf(sign: int): Quat {
	inf := math::Inf(sign)
	ret Quat{inf, inf, inf, inf}
}