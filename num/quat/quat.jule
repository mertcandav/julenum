// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/fmt"
use "std/math"

// Quaternion with floating-point precision.
struct Quat {
	R: f64
	I: f64
	J: f64
	K: f64
}

impl Quat {
	// Reports whether any field of quaternion is NaN and none are an infinity.
	fn NaN(*self): bool {
		if math::IsInf(self.R, 0) || math::IsInf(self.I, 0) ||
			math::IsInf(self.J, 0) || math::IsInf(self.K, 0) {
			ret false
		}
		ret math::IsNaN(self.R) || math::IsNaN(self.I) ||
			math::IsNaN(self.J) || math::IsNaN(self.K)
	}

	// Reports whether any of field of quaternion is ±infinity.
	fn Inf(*self): bool {
		ret math::IsInf(self.R, 0) || math::IsInf(self.I, 0) ||
			math::IsInf(self.J, 0) || math::IsInf(self.K, 0)
	}

	// Reports whether all fields of quaternion is zero.
	fn Zero(*self): bool {
		ret self.R == 0 && self.I == 0 && self.J == 0 && self.K == 0
	}

	// Sets self to the sum of x+y.
	fn Add(mut *self, &x: *Quat, &y: *Quat) {
		self.R, self.I, self.J, self.K = x.R+y.R, x.I+y.I, x.J+y.J, x.K+y.K
	}

	// Sets self to the difference x-y.
	fn Sub(mut *self, &x: *Quat, &y: *Quat) {
		self.R, self.I, self.J, self.K = x.R-y.R, x.I-y.I, x.J-y.J, x.K-y.K
	}

	// Sets self to the Hamiltonian product x*y.
	fn Mul(mut *self, &x: *Quat, &y: *Quat) {
		r := x.R*y.R - x.I*y.I - x.J*y.J - x.K*y.K
		i := x.R*y.I + x.I*y.R + x.J*y.K - x.K*y.J
		j := x.R*y.J - x.I*y.K + x.J*y.R + x.K*y.I
		k := x.R*y.K + x.I*y.J - x.J*y.I + x.K*y.R
		self.R, self.I, self.J, self.K = r, i, j, k
	}

	// Sets self to the product x*k.
	fn Scale(mut *self, &x: *Quat, k: f64) {
		self.R, self.I, self.J, self.K = x.R*k, x.I*k, x.J*k, x.K*k
	}

	// Sets self to the quaternion conjugate of x.
	fn Conj(mut *self, &x: *Quat) {
		self.R, self.I, self.J, self.K = x.R, -x.I, -x.J, -x.K
	}

	// Sets self to the quaternion inverse of x.
	fn Inv(mut *self, &x: *Quat) {
		if x.Inf() {
			lift(self, 0)
			ret
		}
		a := x.Abs()
		self.Conj(x)
		self.Scale(self, 1/(a*a))
	}

	// Sets self to the product e**x, the base-e exponential of x.
	fn Exp(mut *self, &x: *Quat) {
		w, uv := split(x)
		if uv.Zero() {
			lift(self, math::Exp(w))
			ret
		}
		v := uv.Abs()
		e := math::Exp(w)
		s, c := math::Sincos(v)
		self.Scale(&uv, e*s/v)
		join(self, e*c)
	}

	// Sets self to the natural logarithm of x.
	fn Log(mut *self, &x: *Quat) {
		w, uv := split(x)
		if uv.Zero() {
			lift(self, math::Log(w))
			ret
		}
		a := x.Abs()
		v := uv.Abs()
		self.Scale(&uv, math::Atan2(v, w)/v)
		join(self, math::Log(a))
	}

	// Sets self to the product q**r, the base-q exponential of r.
	// For generalized compatibility with math::Pow:
	//
	//	Pow(0, ±0) returns 1+0i+0j+0k
	//	Pow(0, c) for real(c)<0 returns Inf+0i+0j+0k if imag(c), jmag(c), kmag(c) are zero,
	//	    otherwise Inf+Inf i+Inf j+Inf k.
	fn Pow(mut *self, &q: *Quat, &r: *Quat) {
		if q.Zero() {
			w, uv := split(r)
			match {
			| w == 0:
				lift(self, 1)
				ret
			| w < 0:
				if uv.Zero() {
					lift(self, math::Inf(1))
				} else {
					*self = Inf(1)
				}
			| w > 0:
				lift(self, 0)
				ret
			}
		}
		// exp(log(q) * r)
		self.Log(q)
		self.Mul(self, r)
		self.Exp(self)
	}

	// Sets self to the product q**r, the base-q exponential of r.
	// For generalized compatibility with math::Pow:
	//
	//	PowReal(0, ±0) returns 1+0i+0j+0k
	//	PowReal(0, c) for c<0 returns Inf+0i+0j+0k.
	fn PowReal(mut *self, &q: *Quat, r: f64) {
		if q.Zero() {
			match {
			| r == 0:
				lift(self, 1)
			| r < 0:
				*self = Inf(1)
			| r > 0:
				lift(self, 0)
				ret
			}
		}
		// exp(scale(r, log(q)))
		self.Log(q)
		self.Scale(self, r)
		self.Exp(self)
	}

	// Sets self to the √q.
	fn Sqrt(mut *self, &q: *Quat) {
		if q.Zero() {
			lift(self, 0)
			ret
		}
		self.PowReal(q, 0.5)
	}

	// Sets self to the sine of q.
	fn Sin(mut *self, &q: *Quat) {
		w, uv := split(q)
		if uv.Zero() {
			lift(self, math::Sin(w))
			ret
		}
		v := uv.Abs()
		s, c := math::Sincos(w)
		sh, ch := sinhcosh(v)
		self.Scale(&uv, c*sh/v)
		join(self, s*ch)
	}

	// Sets self to the hyperbolic sine of q.
	fn Sinh(mut *self, &q: *Quat) {
		w, uv := split(q)
		if uv.Zero() {
			lift(self, math::Sinh(w))
			ret
		}
		v := uv.Abs()
		s, c := math::Sincos(v)
		sh, ch := sinhcosh(w)
		scale(self, &uv, s*ch/v)
		join(self, c*sh)
	}

	// Sets self to the cosine of q.
	fn Cos(mut *self, &q: *Quat) {
		w, uv := split(q)
		if uv.Zero() {
			lift(self, math::Cos(w))
			ret
		}
		v := uv.Abs()
		s, c := math::Sincos(w)
		sh, ch := sinhcosh(v)
		self.Scale(&uv, -s*sh/v)
		join(self, c*ch)
	}

	// Sets self to the inverse hyperbolic sine of q.
	fn Asinh(mut *self, &q: *Quat) {
		mut p := Quat{R: 1}
		mut r := *self // q may be alias for self.
		r.Mul(q, q)
		r.Add(&r, &p)
		r.Sqrt(&r)
		r.Add(&r, q)
		self.Log(&r)
	}

	// Returns the absolute value (also called the modulus) of quaternion.
	//
	// Special cases:
	//	Abs() = +Inf, if quaternion is ±Inf.
	//	Abs() = NaN, if quaternion is NaN
	fn Abs(*self): f64 {
		// Special cases.
		match {
		| self.Inf():
			ret math::Inf(1)
		| self.NaN():
			ret math::NaN()
		}

		mut r, mut i, mut j, mut k := self.R, self.I, self.J, self.K
		if r < 0 {
			r = -r
		}
		if i < 0 {
			i = -i
		}
		if j < 0 {
			j = -j
		}
		if k < 0 {
			k = -k
		}
		if r < i {
			r, i = i, r
		}
		if r < j {
			r, j = j, r
		}
		if r < k {
			r, k = k, r
		}
		if r == 0 {
			ret 0
		}
		i /= r
		j /= r
		k /= r
		ret r * math::Sqrt(1+i*i+j*j+k*k)
	}
}

// Returns a quaternion NaN.
fn NaN(): Quat {
	nan := math::NaN()
	ret Quat{nan, nan, nan, nan}
}

// Returns a quaternion ±infinity by sign.
fn Inf(sign: int): Quat {
	inf := math::Inf(sign)
	ret Quat{inf, inf, inf, inf}
}

fn lift(mut &q: *Quat, v: f64) {
	q.R, q.I, q.J, q.K = v, 0, 0, 0
}

fn split(&q: *Quat): (f64, Quat) {
	ret q.R, Quat{0, q.I, q.J, q.K}
}

fn join(mut &uv: *Quat, w: f64) {
	uv.R = w
}

// calculate sinh and cosh
fn sinhcosh(x: f64): (sh: f64, ch: f64) {
	if math::Abs(x) <= 0.5 {
		ret math::Sinh(x), math::Cosh(x)
	}
	mut e := math::Exp(x)
	ei := 0.5 / e
	e *= 0.5
	ret e - ei, e + ei
}

// Sets z to q scaled by f, except that inf×0 is 0.
fn scale(mut &z: *Quat, &q: *Quat, f: f64) {
	if f == 0 {
		lift(z, 0)
		ret
	}
	if q.R != 0 {
		z.R = q.R * f
	}
	if q.I != 0 {
		z.I = q.I * f
	}
	if q.J != 0 {
		z.J = q.J * f
	}
	if q.K != 0 {
		z.K = q.K * f
	}
}