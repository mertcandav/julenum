// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "julenum/num/quat"

// Dual quaternion with floating-point precision.
struct Quat {
	X: quat::Quat
	Y: quat::Quat
}

impl Quat {
	// Reports whether all fields of dual quaternion are zero.
	fn Zero(*self): bool {
		ret self.X.Zero() && self.Y.Zero()
	}

	// Sets self to the sum x+y.
	fn Add(mut *self, &x: *Quat, &y: *Quat) {
		self.X.Add(&x.X, &y.X)
		self.Y.Add(&x.Y, &y.Y)
	}

	// Sets self to the difference x-y.
	fn Sub(mut *self, &x: *Quat, &y: *Quat) {
		self.X.Sub(&x.X, &y.X)
		self.Y.Sub(&x.Y, &y.Y)
	}

	// Sets self to the product x*y.
	fn Mul(mut *self, &x: *Quat, &y: *Quat) {
		let mut xy: quat::Quat // xy = x.X * y.Y
		xy.Mul(&x.X, &y.Y)
		let mut yx: quat::Quat // yx = x.Y * y.X
		yx.Mul(&x.Y, &y.X)
		self.X.Mul(&x.X, &y.X) // x = x.X * y.Y
		self.Y.Add(&xy, &yx)   // y = x.X*y.Y + x.Y*y.X
	}
}