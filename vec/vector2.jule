// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/math"

// 2D vector.
struct Vector2 {
	X: f64
	Y: f64
}

impl Vector2 {
	// Sets self to the sum x+y.
	fn Add(mut *self, &x: *Vector2, &y: *Vector2) {
		self.X, self.Y = x.X+y.X, x.Y+y.Y
	}

	// Sets self to the difference x-y.
	fn Sub(mut *self, &x: *Vector2, &y: *Vector2) {
		self.X, self.Y = x.X-y.X, x.Y-y.Y
	}

	// Returns the dot product self*y.
	fn Dot(*self, &y: *Vector2): f64 {
		ret self.X*y.X + self.Y*y.Y
	}

	// Sets self to the product x*y.
	fn Mul(mut *self, &x: *Vector2, y: f64) {
		self.X, self.Y = x.X*y, x.Y*y
	}

	// Sets self to the quotient x/y.
	fn Div(mut *self, &x: *Vector2, y: f64) {
		self.X, self.Y = x.X/y, x.Y/y
	}

	// Returns length of vector.
	fn Len(*self): f64 {
		ret math::Sqrt(self.X*self.X + self.Y*self.Y)
	}

	// Sets self to the unit vector (vector with length 1) in the same direction as x.
	// If the vector x has zero length, it returns the zero vector (0, 0) to avoid division by zero.
	fn Norm(mut *self, &x: *Vector2) {
		len := x.Len()
		if len == 0 {
			self.X, self.Y = 0, 0
		}
		self.X, self.Y = x.X/len, x.Y/len
	}

	// Returns the angle in radians between self and y vectors.
	fn AngleBetween(*self, &y: *Vector2): f64 {
		lenProduct := self.Len() * y.Len()
		if lenProduct == 0 {
			ret 0
		}
		dot := self.Dot(y)
		mut cosTheta := dot / lenProduct
		// Clamp to avoid NaN due to floating-point error.
		if cosTheta > 1 {
			cosTheta = 1
		} else if cosTheta < -1 {
			cosTheta = -1
		}
		ret math::Acos(cosTheta)
	}

	// Sets self to the x vector rotated by theta radians.
	fn Rotate(mut *self, &x: *Vector2, theta: f64) {
		sin, cos := math::Sincos(theta)
		self.X, self.Y = x.X*cos-x.Y*sin, x.X*sin+x.Y*cos
	}
}