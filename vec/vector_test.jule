// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/math"
use "std/slices"
use "std/testing"

struct vectorCSTest {
	x:    Vector[f64]
	norm: f64
	y:    Vector[f64]
	dot:  f64
	add:  Vector[f64]
	sub:  Vector[f64]
}

let mut testsVectorCS: []vectorCSTest = [
	{
		x: [],
		norm: 0,
		y: [],
		dot: 0,
		add: [],
		sub: [],
	},
	{
		x: [1, 2, 3, 4],
		norm: math::Sqrt(1*1 + 2*2 + 3*3 + 4*4),
		y: [1, 2, 3, 4],
		dot: 1*1 + 2*2 + 3*3 + 4*4,
		add: [2, 4, 6, 8],
		sub: [0, 0, 0, 0],
	},
	{
		x: [10, 20, 30, 40],
		norm: math::Sqrt(10*10 + 20*20 + 30*30 + 40*40),
		y: [0, 0, 0, 0],
		dot: 0,
		add: [10, 20, 30, 40],
		sub: [10, 20, 30, 40],
	},
	{
		x: [10, 20, 30, 40],
		norm: math::Sqrt(10*10 + 20*20 + 30*30 + 40*40),
		y: [10, 10, 10, 10],
		dot: 10*10 + 20*10 + 30*10 + 40*10,
		add: [20, 30, 40, 50],
		sub: [0, 10, 20, 30],
	},
]

fn testVectorCS(t: &testing::T, name: str, f: fn(mut vectorCSTest): (Vector[f64], Vector[f64])) {
	for (_, mut test) in testsVectorCS {
		got, want := f(test)
		if !slices::Equal([]f64(got), []f64(want)) {
			t.Errorf("{}({}, {}) = {}, expected {}", name, test.x, test.y, got, want)
		}
	}
}

#test
fn testVectorAdd(t: &testing::T) {
	testVectorCS(t, "Add", fn|mut test| {
		mut z := make(Vector[f64], len(test.x))
		copy(z, test.x)
		z.Add(&test.x, &test.y)
		ret z, test.add
	})
}

#test
fn testVectorSub(t: &testing::T) {
	testVectorCS(t, "Sub", fn|mut test| {
		mut z := make(Vector[f64], len(test.x))
		copy(z, test.x)
		z.Sub(&test.x, &test.y)
		ret z, test.sub
	})
}

#test
fn testVectorDot(t: &testing::T) {
	for (_, mut test) in testsVectorCS {
		got := test.x.Dot(&test.y)
		if got != test.dot {
			t.Errorf("Dot({}, {}) = {}, expected {}", test.x, test.y, got, test.dot)
		}
	}
}

#test
fn testVectorNorm(t: &testing::T) {
	for (_, mut test) in testsVectorCS {
		got := test.x.Norm()
		if got != test.norm {
			t.Errorf("Norm({}, {}) = {}, expected {}", test.x, test.y, got, test.norm)
		}
	}
}