// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// General vector type for type T.
type Vector[T: integer | float]: []T

impl Vector {
	// Returns new Vector buffer enough to store at least n values.
	fn make(mut *self, n: int): Vector[T] {
		// Reuse self capacity, if there is enough space.
		if n <= cap(*self) {
			ret (*self)[:n]
		}
		ret make(Vector[T], n)
	}

	// Sets self to the sum x+y.
	// x any y must have same length.
	//
	// If self have enough capacity, Add will use it to avoid making allocation.
	// If length is zero, self will be zero-length. But keeps internal allocation.
	#disable boundary
	fn Add(mut *self, &x: *Vector[T], &y: *Vector[T]) {
		if len(*x) != len(*y) {
			panic("vec: Vector.Add: len(x) != len(y)")
		}
		if len(*x) == 0 {
			*self = (*self)[:0]
		}

		// Make sure the self data have enough space.
		*self = self.make(len(*x))

		mut i := 0
		for i < len(*self); i++ {
			(*self)[i] = (*x)[i] + (*y)[i]
		}
	}

	// Sets self to the difference x-y.
	// x any y must have same length.
	//
	// If self have enough capacity, Sub will use it to avoid making allocation.
	// If length is zero, self will be zero-length. But keeps internal allocation.
	#disable boundary
	fn Sub(mut *self, &x: *Vector[T], &y: *Vector[T]) {
		if len(*x) != len(*y) {
			panic("vec: Vector.Sub: len(x) != len(y)")
		}
		if len(*x) == 0 {
			*self = (*self)[:0]
		}

		// Make sure the self data have enough space.
		*self = self.make(len(*x))

		mut i := 0
		for i < len(*self); i++ {
			(*self)[i] = (*x)[i] - (*y)[i]
		}
	}
}