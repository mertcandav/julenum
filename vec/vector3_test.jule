// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "julenum"
use "std/testing"

struct testVector3XYR {
	x: Vector3
	y: Vector3
	r: Vector3
}

let testsVector3Proj: []testVector3XYR = [
	{
		x: {4, 2, 1},
		y: {1, 0, 0},
		r: {4, 0, 0},
	},
	{
		x: {3, -2, 5},
		y: {0, 1, 0},
		r: {0, -2, 0},
	},
	{
		x: {6, 3, -2},
		y: {2, 1, -1},
		r: {5.666666666666667, 2.8333333333333335, -2.8333333333333335},
	},
	{
		x: {1, 1, 1},
		y: {-1, 2, 3},
		r: {-0.2857142857142857, 0.5714285714285714, 0.8571428571428571},
	},
	{
		x: {5, 0, 0},
		y: {0, 5, 0},
		r: {0, 0, 0},
	},
]

#test
fn testVector3Proj(t: &testing::T) {
	for _, test in testsVector3Proj {
		mut x, y := test.x, test.y
		x.Proj(&x, &y)
		if !julenum::VeryClose(x.X, test.r.X) || !julenum::VeryClose(x.Y, test.r.Y) || !julenum::VeryClose(x.Z, test.r.Z) {
			t.Errorf("expected {}, found {}, for Proj({}, {})", test.r, x, test.x, test.y)
		}
	}
}