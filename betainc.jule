// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Implementation derived from the gonum.
//
// Copyright ©2016 The Gonum Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

use "std/math"

// Returns the value of the regularized incomplete beta function
// I(x;a,b). It is defined as
//
//	I(x;a,b) = B(x;a,b) / B(a,b)
//	         = Γ(a+b) / (Γ(a)*Γ(b)) * int_0^x u^(a-1) * (1-u)^(b-1) du.
//
// The domain of definition is 0 <= x <= 1, and the parameters a and b must be positive.
// For other values of x, a, and b, it will panic.
fn RegIncBeta(a: f64, b: f64, x: f64): f64 {
	ret incbet(a, b, x)
}

// Computes the inverse of the regularized incomplete beta function.
// It returns the x for which
//
//	y = I(x;a,b)
//
// The domain of definition is 0 <= y <= 1, and the parameters a and b must be
// positive. For other values of x, a, and b, it will panic.
fn InvRegIncBeta(a: f64, b: f64, y: f64): f64 {
	if y < 0 || 1 < y {
		panic("julenum: parameter out of range")
	}
	ret incbi(a, b, y)
}

/*
 * Cephes Math Library, Release 2.3:  March, 1995
 * Copyright 1984, 1995 by Stephen L. Moshier
 */

/*
Additional copyright information:

Code in following lines is adapted from the Cephes library (http://www.netlib.org/cephes/).
There is no explicit licence on Netlib, but the author has agreed to a BSD release.
See https://github.com/deepmind/torch-cephes/blob/master/LICENSE.txt and
https://lists.debian.org/debian-legal/2004/12/msg00295.html
*/

const (
	paramOutOfBounds            = "julenum: parameter out of bounds"
	errParamFunctionSingularity = "julenum: function singularity"
)

const (
	machEp  = 1.0 / (1 << 53)
	maxLog  = 1024 * Ln2
	minLog  = -1075 * Ln2
	maxIter = 2000
)

const (
	maxGam = 171.624376956302725
	big    = 4.503599627370496e15
	biginv = 2.22044604925031308085e-16
)

// Computes the regularized incomplete beta function.
fn incbet(aa: f64, bb: f64, xx: f64): f64 {
	if aa <= 0 || bb <= 0 {
		panic(paramOutOfBounds)
	}
	if xx <= 0 || xx >= 1 {
		if xx == 0 {
			ret 0
		}
		if xx == 1 {
			ret 1
		}
		panic(paramOutOfBounds)
	}

	let mut flag: int
	if bb*xx <= 1 && xx <= 0.95 {
		t := pseries(aa, bb, xx)
		ret transformT(t, flag)
	}

	mut w := 1 - xx

	// Reverse a and b if x is greater than the mean.
	let mut a: f64
	let mut b: f64
	let mut xc: f64
	let mut x: f64
	if xx > aa/(aa+bb) {
		flag = 1
		a = bb
		b = aa
		xc = xx
		x = w
	} else {
		a = aa
		b = bb
		xc = w
		x = xx
	}

	if flag == 1 && (b*x) <= 1.0 && x <= 0.95 {
		t := pseries(a, b, x)
		ret transformT(t, flag)
	}

	// Choose expansion for better convergence.
	mut y := x*(a+b-2.0) - (a - 1.0)
	if y < 0.0 {
		w = incbcf(a, b, x)
	} else {
		w = incbd(a, b, x) / xc
	}

	// Multiply w by the factor
	// x^a * (1-x)^b * Γ(a+b) / (a*Γ(a)*Γ(b))
	let mut t: f64
	y = a * math::Log(x)
	t = b * math::Log(xc)
	if (a+b) < maxGam && math::Abs(y) < maxLog && math::Abs(t) < maxLog {
		t = math::Pow(xc, b)
		t *= math::Pow(x, a)
		t /= a
		t *= w
		t *= 1.0 / Beta(a, b)
		ret transformT(t, flag)
	}

	// Resort to logarithms.
	y += t - Lbeta(a, b)
	y += math::Log(w / a)
	if y < minLog {
		t = 0.0
	} else {
		t = math::Exp(y)
	}

	ret transformT(t, flag)
}

fn transformT(mut t: f64, flag: int): f64 {
	if flag == 1 {
		if t <= machEp {
			t = 1.0 - machEp
		} else {
			t = 1.0 - t
		}
	}
	ret t
}

// Returns the incomplete beta integral evaluated by a continued fraction expansion.
fn incbcf(a: f64, b: f64, x: f64): f64 {
	let mut xk: f64
	let mut pk: f64
	let mut pkm1: f64
	let mut pkm2: f64
	let mut qk: f64
	let mut qkm1: f64
	let mut qkm2: f64
	let mut k1: f64
	let mut k2: f64
	let mut k3: f64
	let mut k4: f64
	let mut k5: f64
	let mut k6: f64
	let mut k7: f64
	let mut k8: f64
	let mut r: f64
	let mut t: f64
	let mut ans: f64
	let mut thresh: f64
	let mut n: int

	k1 = a
	k2 = a + b
	k3 = a
	k4 = a + 1.0
	k5 = 1.0
	k6 = b - 1.0
	k7 = k4
	k8 = a + 2.0

	pkm2 = 0.0
	qkm2 = 1.0
	pkm1 = 1.0
	qkm1 = 1.0
	ans = 1.0
	r = 1.0
	thresh = 3.0 * machEp

	n = 0
	for n <= 300; n++ {
		xk = -(x * k1 * k2) / (k3 * k4)
		pk = pkm1 + pkm2*xk
		qk = qkm1 + qkm2*xk
		pkm2 = pkm1
		pkm1 = pk
		qkm2 = qkm1
		qkm1 = qk

		xk = (x * k5 * k6) / (k7 * k8)
		pk = pkm1 + pkm2*xk
		qk = qkm1 + qkm2*xk
		pkm2 = pkm1
		pkm1 = pk
		qkm2 = qkm1
		qkm1 = qk

		if qk != 0 {
			r = pk / qk
		}
		if r != 0 {
			t = math::Abs((ans - r) / r)
			ans = r
		} else {
			t = 1.0
		}

		if t < thresh {
			ret ans
		}

		k1 += 1.0
		k2 += 1.0
		k3 += 2.0
		k4 += 2.0
		k5 += 1.0
		k6 -= 1.0
		k7 += 2.0
		k8 += 2.0

		if (math::Abs(qk)+math::Abs(pk)) > big {
			pkm2 *= biginv
			pkm1 *= biginv
			qkm2 *= biginv
			qkm1 *= biginv
		}
		if (math::Abs(qk) < biginv) || (math::Abs(pk) < biginv) {
			pkm2 *= big
			pkm1 *= big
			qkm2 *= big
			qkm1 *= big
		}
	}

	ret ans
}

// Returns the incomplete beta integral evaluated by a continued fraction expansion.
fn incbd(a: f64, b: f64, x: f64): f64 {
	let mut xk: f64
	let mut pk: f64
	let mut pkm1: f64
	let mut pkm2: f64
	let mut qk: f64
	let mut qkm1: f64
	let mut qkm2: f64
	let mut k1: f64
	let mut k2: f64
	let mut k3: f64
	let mut k4: f64
	let mut k5: f64
	let mut k6: f64
	let mut k7: f64
	let mut k8: f64
	let mut r: f64
	let mut t: f64
	let mut ans: f64
	let mut z: f64
	let mut thresh: f64
	let mut n: int

	k1 = a
	k2 = b - 1.0
	k3 = a
	k4 = a + 1.0
	k5 = 1.0
	k6 = a + b
	k7 = a + 1.0
	k8 = a + 2.0

	pkm2 = 0.0
	qkm2 = 1.0
	pkm1 = 1.0
	qkm1 = 1.0
	z = x / (1.0 - x)
	ans = 1.0
	r = 1.0
	thresh = 3.0 * machEp
	n = 0
	for n <= 300; n++ {
		xk = -(z * k1 * k2) / (k3 * k4)
		pk = pkm1 + pkm2*xk
		qk = qkm1 + qkm2*xk
		pkm2 = pkm1
		pkm1 = pk
		qkm2 = qkm1
		qkm1 = qk

		xk = (z * k5 * k6) / (k7 * k8)
		pk = pkm1 + pkm2*xk
		qk = qkm1 + qkm2*xk
		pkm2 = pkm1
		pkm1 = pk
		qkm2 = qkm1
		qkm1 = qk

		if qk != 0 {
			r = pk / qk
		}
		if r != 0 {
			t = math::Abs((ans - r) / r)
			ans = r
		} else {
			t = 1.0
		}

		if t < thresh {
			ret ans
		}

		k1 += 1.0
		k2 -= 1.0
		k3 += 2.0
		k4 += 2.0
		k5 += 1.0
		k6 += 1.0
		k7 += 2.0
		k8 += 2.0

		if (math::Abs(qk)+math::Abs(pk)) > big {
			pkm2 *= biginv
			pkm1 *= biginv
			qkm2 *= biginv
			qkm1 *= biginv
		}
		if (math::Abs(qk) < biginv) || (math::Abs(pk) < biginv) {
			pkm2 *= big
			pkm1 *= big
			qkm2 *= big
			qkm1 *= big
		}
	}
	ret ans
}

// Returns the incomplete beta integral evaluated by a power series. Use
// when b*x is small and x not too close to 1.
fn pseries(a: f64, b: f64, x: f64): f64 {
	let mut s: f64
	let mut t: f64
	let mut u: f64
	let mut v: f64
	let mut n: f64
	let mut t1: f64
	let mut z: f64
	let mut ai: f64
	ai = 1.0 / a
	u = (1.0 - b) * x
	v = u / (a + 1.0)
	t1 = v
	t = u
	n = 2.0
	s = 0.0
	z = machEp * ai
	for math::Abs(v) > z {
		u = (n - b) * x / n
		t *= u
		v = t / (a + n)
		s += v
		n += 1.0
	}
	s += t1
	s += ai

	u = a * math::Log(x)
	if (a+b) < maxGam && math::Abs(u) < maxLog {
		t = 1.0 / Beta(a, b)
		s = s * t * math::Pow(x, a)
	} else {
		t = -Lbeta(a, b) + u + math::Log(s)
		if t < minLog {
			s = 0.0
		} else {
			s = math::Exp(t)
		}
	}
	ret s
}

// Computes the inverse of the regularized incomplete beta integral.
fn incbi(aa: f64, bb: f64, yy0: f64): f64 {
	let mut a: f64
	let mut b: f64
	let mut y0: f64
	let mut d: f64
	let mut y: f64
	let mut x: f64
	let mut x0: f64
	let mut x1: f64
	let mut lgm: f64
	let mut yp: f64
	let mut di: f64
	let mut dithresh: f64
	let mut yl: f64
	let mut yh: f64
	let mut xt: f64
	let mut i: int
	let mut rflg: int
	let mut dir: int
	let mut nflg: int

	if yy0 <= 0 {
		ret 0.0
	}
	if yy0 >= 1.0 {
		ret 1.0
	}
	x0 = 0.0
	yl = 0.0
	x1 = 1.0
	yh = 1.0
	nflg = 0

	if aa <= 1.0 || bb <= 1.0 {
		dithresh = 1.0e-6
		rflg = 0
		a = aa
		b = bb
		y0 = yy0
		x = a / (a + b)
		y = incbet(a, b, x)
		goto ihalve
	} else {
		dithresh = 1.0e-4
	}
	// Approximation to inverse function
	yp = -ndtri(yy0)

	if yy0 > 0.5 {
		rflg = 1
		a = bb
		b = aa
		y0 = 1.0 - yy0
		yp = -yp
	} else {
		rflg = 0
		a = aa
		b = bb
		y0 = yy0
	}

	lgm = (yp*yp - 3.0) / 6.0
	x = 2.0 / (1.0/(2.0*a-1.0) + 1.0/(2.0*b-1.0))
	d = yp*math::Sqrt(x+lgm)/x - (1.0/(2.0*b-1.0)-1.0/(2.0*a-1.0))*(lgm+5.0/6.0-2.0/(3.0*x))
	d = 2.0 * d
	if d < minLog {
		// mtherr("incbi", UNDERFLOW)
		x = 0
		goto done
	}
	x = a / (a + b*math::Exp(d))
	y = incbet(a, b, x)
	yp = (y - y0) / y0
	if math::Abs(yp) < 0.2 {
		goto newt
	}

	/* Resort to interval halving if not close enough. */
ihalve:

	dir = 0
	di = 0.5
	i = 0
	for i < 100; i++ {
		if i != 0 {
			x = x0 + di*(x1-x0)
			if x == 1.0 {
				x = 1.0 - machEp
			}
			if x == 0.0 {
				di = 0.5
				x = x0 + di*(x1-x0)
				if x == 0.0 {
					// mtherr("incbi", UNDERFLOW)
					goto done
				}
			}
			y = incbet(a, b, x)
			yp = (x1 - x0) / (x1 + x0)
			if math::Abs(yp) < dithresh {
				goto newt
			}
			yp = (y - y0) / y0
			if math::Abs(yp) < dithresh {
				goto newt
			}
		}
		if y < y0 {
			x0 = x
			yl = y
			if dir < 0 {
				dir = 0
				di = 0.5
			} else if dir > 3 {
				di = 1.0 - (1.0-di)*(1.0-di)
			} else if dir > 1 {
				di = 0.5*di + 0.5
			} else {
				di = (y0 - y) / (yh - yl)
			}
			dir += 1
			if x0 > 0.75 {
				if rflg == 1 {
					rflg = 0
					a = aa
					b = bb
					y0 = yy0
				} else {
					rflg = 1
					a = bb
					b = aa
					y0 = 1.0 - yy0
				}
				x = 1.0 - x
				y = incbet(a, b, x)
				x0 = 0.0
				yl = 0.0
				x1 = 1.0
				yh = 1.0
				goto ihalve
			}
		} else {
			x1 = x
			if rflg == 1 && x1 < machEp {
				x = 0.0
				goto done
			}
			yh = y
			if dir > 0 {
				dir = 0
				di = 0.5
			} else if dir < -3 {
				di = di * di
			} else if dir < -1 {
				di = 0.5 * di
			} else {
				di = (y - y0) / (yh - yl)
			}
			dir -= 1
		}
	}
	// mtherr("incbi", PLOSS)
	if x0 >= 1.0 {
		x = 1.0 - machEp
		goto done
	}
	if x <= 0.0 {
		// mtherr("incbi", UNDERFLOW)
		x = 0.0
		goto done
	}

newt:
	if nflg > 0 {
		goto done
	}
	nflg = 1
	lgm = lgam(a+b) - lgam(a) - lgam(b)

	i = 0
	for i < 8; i++ {
		/* Compute the function at this point. */
		if i != 0 {
			y = incbet(a, b, x)
		}
		if y < yl {
			x = x0
			y = yl
		} else if y > yh {
			x = x1
			y = yh
		} else if y < y0 {
			x0 = x
			yl = y
		} else {
			x1 = x
			yh = y
		}
		if x == 1.0 || x == 0.0 {
			break
		}
		/* Compute the derivative of the function at this point. */
		d = (a-1.0)*math::Log(x) + (b-1.0)*math::Log(1.0-x) + lgm
		if d < minLog {
			goto done
		}
		if d > maxLog {
			break
		}
		d = math::Exp(d)
		/* Compute the step to the next approximation of x. */
		d = (y - y0) / d
		xt = x - d
		if xt <= x0 {
			y = (x - x0) / (x1 - x0)
			xt = x0 + 0.5*y*(x-x0)
			if xt <= 0.0 {
				break
			}
		}
		if xt >= x1 {
			y = (x1 - x) / (x1 - x0)
			xt = x1 - 0.5*y*(x1-x)
			if xt >= 1.0 {
				break
			}
		}
		x = xt
		if math::Abs(d/x) < 128.0*machEp {
			goto done
		}
	}
	/* Did not converge. */
	dithresh = 256.0 * machEp
	goto ihalve

done:

	if rflg > 0 {
		if x <= machEp {
			x = 1.0 - machEp
		} else {
			x = 1.0 - x
		}
	}
	ret x
}

fn lgam(a: f64): f64 {
	lg, _ := math::Lgamma(a)
	ret lg
}

// math::Sqrt(2*pi)
const s2pi = 2.50662827463100050242e0

// approximation for 0 <= |y - 0.5| <= 3/8
let P0: [5]f64 = [
	-5.99633501014107895267e1,
	9.80010754185999661536e1,
	-5.66762857469070293439e1,
	1.39312609387279679503e1,
	-1.23916583867381258016e0,
]

let Q0: [8]f64 = [
	/* 1.00000000000000000000E0, */
	1.95448858338141759834e0,
	4.67627912898881538453e0,
	8.63602421390890590575e1,
	-2.25462687854119370527e2,
	2.00260212380060660359e2,
	-8.20372256168333339912e1,
	1.59056225126211695515e1,
	-1.18331621121330003142e0,
]

// Approximation for interval z = math.Sqrt(-2 log y ) between 2 and 8
// i.e., y between exp(-2) = .135 and exp(-32) = 1.27e-14.
let P1: [9]f64 = [
	4.05544892305962419923e0,
	3.15251094599893866154e1,
	5.71628192246421288162e1,
	4.40805073893200834700e1,
	1.46849561928858024014e1,
	2.18663306850790267539e0,
	-1.40256079171354495875e-1,
	-3.50424626827848203418e-2,
	-8.57456785154685413611e-4,
]

let Q1: [8]f64 = [
	/*  1.00000000000000000000E0, */
	1.57799883256466749731e1,
	4.53907635128879210584e1,
	4.13172038254672030440e1,
	1.50425385692907503408e1,
	2.50464946208309415979e0,
	-1.42182922854787788574e-1,
	-3.80806407691578277194e-2,
	-9.33259480895457427372e-4,
]

// Approximation for interval z = math.Sqrt(-2 log y ) between 8 and 64
// i.e., y between exp(-32) = 1.27e-14 and exp(-2048) = 3.67e-890.
let P2: [9]f64 = [
	3.23774891776946035970e0,
	6.91522889068984211695e0,
	3.93881025292474443415e0,
	1.33303460815807542389e0,
	2.01485389549179081538e-1,
	1.23716634817820021358e-2,
	3.01581553508235416007e-4,
	2.65806974686737550832e-6,
	6.23974539184983293730e-9,
]

let Q2: [8]f64 = [
	/*  1.00000000000000000000E0, */
	6.02427039364742014255e0,
	3.67983563856160859403e0,
	1.37702099489081330271e0,
	2.16236993594496635890e-1,
	1.34204006088543189037e-2,
	3.28014464682127739104e-4,
	2.89247864745380683936e-6,
	6.79019408009981274425e-9,
]

// Returns the argument, x, for which the area under the
// Gaussian probability density function (integrated from
// minus infinity to x) is equal to y.
fn ndtri(y0: f64): f64 {
	// For small arguments 0 < y < exp(-2), the program computes
	// z = math.Sqrt( -2.0 * math.Log(y) );  then the approximation is
	// x = z - math.Log(z)/z  - (1/z) P(1/z) / Q(1/z).
	// There are two rational functions P/Q, one for 0 < y < exp(-32)
	// and the other for y up to exp(-2).  For larger arguments,
	// w = y - 0.5, and  x/math.Sqrt(2pi) = w + w**3 R(w**2)/S(w**2)).

	let mut x: f64
	let mut y: f64
	let mut z: f64
	let mut y2: f64
	let mut x0: f64
	let mut x1: f64
	let mut code: int

	if y0 <= 0.0 {
		if y0 < 0 {
			panic(paramOutOfBounds)
		}
		ret math::Inf(-1)
	}
	if y0 >= 1.0 {
		if y0 > 1 {
			panic(paramOutOfBounds)
		}
		ret math::Inf(1)
	}
	code = 1
	y = y0
	if y > (1.0-0.13533528323661269189) { /* 0.135... = exp(-2) */
		y = 1.0 - y
		code = 0
	}

	if y > 0.13533528323661269189 {
		y = y - 0.5
		y2 = y * y
		x = y + y*(y2*polevl(y2, P0[:], 4)/p1evl(y2, Q0[:], 8))
		x = x * s2pi
		ret x
	}

	x = math::Sqrt(-2.0 * math::Log(y))
	x0 = x - math::Log(x)/x

	z = 1.0 / x
	if x < 8.0 { /* y > exp(-32) = 1.2664165549e-14 */
		x1 = z * polevl(z, P1[:], 8) / p1evl(z, Q1[:], 8)
	} else {
		x1 = z * polevl(z, P2[:], 8) / p1evl(z, Q2[:], 8)
	}
	x = x0 - x1
	if code != 0 {
		x = -x
	}
	ret x
}

// Evaluates a polynomial of degree N
//
//	y = c_0 + c_1 x_1 + c_2 x_2^2 ...
//
// where the coefficients are stored in reverse order, i.e. coef[0] = c_n and
// coef[n] = c_0.
#disable boundary
fn polevl(x: f64, coef: []f64, n: int): f64 {
	mut ans := coef[0]
	mut i := 1
	for i <= n; i++ {
		ans = ans*x + coef[i]
	}
	ret ans
}

// Same as polevl, except c_n is assumed to be 1 and is not included in the slice.
#disable boundary
fn p1evl(x: f64, coef: []f64, n: int): f64 {
	mut ans := x + coef[0]
	mut i := 1
	for i <= n-1; i++ {
		ans = ans*x + coef[i]
	}
	ret ans
}