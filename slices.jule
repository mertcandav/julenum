// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/math"
use "std/math/rand"

// Returns the maximum value of the slice.
// If len(s) == 0, it panics.
//
// Special cases are:
//	Max(...) = NaN, if any value is NaN
#disable boundary
fn Max[T: integer | float](s: ...T): T {
	if len(s) == 0 {
		panic("Max: len(s) == 0")
	}
	mut max := s[0]
	mut i := 1
	for i < len(s); i++ {
		x := s[i]
		if max < x {
			max = x
		}
	}
	ret max
}

// Returns the minimum value of the slice.
// If len(s) == 0, it panics.
//
// Special cases are:
//	Min(...) = NaN, if any value is NaN
#disable boundary
fn Min[T: integer | float](s: ...T): T {
	if len(s) == 0 {
		panic("Min: len(s) == 0")
	}
	mut min := s[0]
	mut i := 1
	for i < len(s); i++ {
		x := s[i]
		if min > x {
			min = x
		}
	}
	ret min
}

// Returns the sum of all values of the slice.
//
// Special cases are:
//	Sum(...) = 0, if len(s) == 0
//	Sum(...) = NaN, if any value is NaN
//	Sum(...) = NaN, if any (+Inf + -Inf) appears
fn Sum[T: numeric](s: ...T): T {
	let mut sum: T
	for _, x in s {
		sum += x
	}
	ret sum
}

// Returns a slice of n evenly spaced values between start and stop, inclusive.
//
// If n is 0, it returns an empty slice. If n is 1, the slice contains only start.
// Otherwise, it returns n values starting from start and ending at stop, linearly spaced.
// It panics if n is negative.
//
// Special cases are:
//	Linspace(start, NaN, n) = [start, NaN, NaN, NaN, ...]
//	Linspace(NaN, stop, n) = [NaN, NaN, NaN, NaN, ...]
//	Linspace(NaN, NaN, n) = [NaN, NaN, NaN, NaN, ...]
//	Linspace(±Inf, stop, n) = [±Inf, NaN, NaN, NaN, ...]
//	Linspace(start, ±Inf, n) = [start, ±Inf, ±Inf, ±Inf, ...]
#disable boundary
fn Linspace[T: integer | float](mut start: T, stop: T, n: int): []T {
	if n == 0 {
		ret make([]T, 0)
	}
	if n < 0 {
		panic("Linspace: n < 0")
	}

	mut r := make([]T, n)
	if start <= stop {
		step := (stop - start) / T(n-1)
		for i in r {
			r[i] = start
			start += step
		}
	} else {
		step := (start - stop) / T(n-1)
		for i in r {
			r[i] = start
			start -= step
		}
	}
	ret r
}

// Returns a slice of evenly spaced values within a given interval.
// The sequence starts at start, increments by step, and stops before stop.
// If step is zero, the function will panic to prevent an infinite loop.
// When using a non-integer step, such as 0.1, it is often better to use Linspace.
//
// Special cases are:
//	Range(NaN, stop, step) = []
//	Range(start, NaN, step) = []
//	Range(start, stop, NaN) = []
//	Range(±Inf, stop, step) = undefined, may cause panic
//	Range(start, ±Inf, step) = undefined, may cause panic
//	Range(start, stop, ±Inf) = undefined, may cause panic
#disable boundary
fn Range[T: integer | float](mut start: T, stop: T, step: T): []T {
	if step == 0 {
		panic("Range: step == 0")
	}

	let mut r: []T
	if start < stop {
		if step < 0 {
			ret make([]T, 0)
		}
		r = make([]T, nor1(int(math::Ceil(f64((stop-start)/step)))))
	} else {
		if step > 0 {
			ret make([]T, 0)
		}
		r = make([]T, nor1(int(math::Ceil(f64((start-stop)/-step)))))
	}
	for i in r {
		r[i] = start
		start += step
	}
	ret r
}

// Makes n guaranteed to be n > 0.
fn nor1(n: int): int {
	if n > 0 {
		ret n
	}
	ret 1
}

#disable boundary
fn quickSelect[T: comparable](mut x: []T, k: int): T {
	mut left, mut right := 0, len(x)-1
	for {
		if left == right {
			ret x[left]
		}

		// Pivot selection (randomized for performance).
		mut pivotIndex := rand::IntN(right-left+1) + left
		pivotIndex = partition(x, left, right, pivotIndex)

		if k == pivotIndex {
			ret x[k]
		} else if k < pivotIndex {
			right = pivotIndex - 1
		} else {
			left = pivotIndex + 1
		}
	}
}

// Rearranges elements and returns the pivot's final index.
#disable boundary
fn partition[T: comparable](mut x: []T, left: int, right: int, pivotIndex: int): int {
	pivotValue := x[pivotIndex]
	// Move pivot to end.
	x[pivotIndex], x[right] = x[right], x[pivotIndex]
	mut storeIndex := left
	mut i := left
	for i < right; i++ {
		if x[i] < pivotValue {
			x[i], x[storeIndex] = x[storeIndex], x[i]
			storeIndex++
		}
	}
	// Move pivot to its final place.
	x[storeIndex], x[right] = x[right], x[storeIndex]
	ret storeIndex
}