// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Returns the maximum value of the slice.
// If len(s) == 0, it panics.
//
// Special cases are:
//	- Max(...) = NaN, if any value is NaN
#disable boundary
fn Max[T: integer | float](s: ...T): T {
	if len(s) == 0 {
		panic("Max: len(s) == 0")
	}
	mut max := s[0]
	mut i := 1
	for i < len(s); i++ {
		x := s[i]
		if max < x {
			max = x
		}
	}
	ret max
}

// Returns the minimum value of the slice.
// If len(s) == 0, it panics.
//
// Special cases are:
//	- Min(...) = NaN, if any value is NaN
#disable boundary
fn Min[T: integer | float](s: ...T): T {
	if len(s) == 0 {
		panic("Min: len(s) == 0")
	}
	mut min := s[0]
	mut i := 1
	for i < len(s); i++ {
		x := s[i]
		if min > x {
			min = x
		}
	}
	ret min
}

// Returns the sum of all values of the slice.
//
// Special cases are:
//	- Sum(...) = 0, if len(s) == 0
//	- Sum(...) = NaN, if any value is NaN
//	- Sum(...) = NaN, if any (+Inf + -Inf) appears
fn Sum[T: numeric](s: ...T): T {
	let mut sum: T
	for _, x in s {
		sum += x
	}
	ret sum
}