// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/testing"

struct chiSquareTest {
	obs:  []f64
	exp:  []f64
	want: f64
}

let testsChiSquare: []chiSquareTest = [
	{
		obs: [10, 12, 8],
		exp: [10, 10, 10],
		want: 0.8,
	},
	{
		obs: [3, 4, 5],
		exp: [3, 4, 5],
		want: 0,
	},
	{
		obs: [0, 3, 0],
		exp: [0, 3, 1],
		want: 1,
	},
]

#test
fn testChiSquare(t: &testing::T) {
	for _, test in testsChiSquare {
		got := ChiSquare(test.obs, test.exp)
		if got != test.want {
			t.Errorf("ChiSquare({}, {}) = {}, expected {}", test.obs, test.exp, got, test.want)
		}
	}
}

let testsChiSquareDistance: []chiSquareTest = [
	{
		obs: [1, 2, 13, 5, 45, 23],
		exp: [67, 90, 18, 79, 24, 98],
		want: 133.55428601494035,
	},
	{
		obs: [91, 900, 78, 30, 602, 813],
		exp: [57, 49, 36, 759, 234, 928],
		want: 814.776999405035,
	},
	{
		obs: [0, 3, 0],
		exp: [0, 3, 0],
		want: 0,
	},
]

#test
fn testChiSquareDistance(t: &testing::T) {
	for _, test in testsChiSquareDistance {
		got := ChiSquareDistance(test.obs, test.exp)
		if got != test.want {
			t.Errorf("ChiSquareDistance({}, {}) = {}, expected {}", test.obs, test.exp, got, test.want)
		}
	}
}

struct meanTest {
	x:    []f64
	want: f64
}

let testsMean: []meanTest = [
	{x: [], want: 0},
	{x: [0, 0, 0], want: 0},
	{x: [1, 2, 3], want: 2},
	{x: [1, 2, 3], want: 2},
	{x: [-34, 34, 0, 4, 834, -34, 74], want: 125.42857142857143},
]

#test
fn testMean(t: &testing::T) {
	for _, test in testsMean {
		got := Mean(test.x)
		if got != test.want {
			t.Errorf("Mean({}) = {}, expected {}", test.x, got, test.want)
		}
	}
}

#test
fn testMeanWeight(t: &testing::T) {
	for _, test in testsMean {
		mut got := MeanWeight(test.x, nil)
		if got != test.want {
			t.Errorf("MeanWeight({}, nil) = {}, expected {}", test.x, got, test.want)
		}
		mut ones := make([]f64, len(test.x))
		for i in ones {
			ones[i] = 1
		}
		got = MeanWeight(test.x, ones)
		if got != test.want {
			t.Errorf("MeanWeight({}, ones) = {}, expected {}", test.x, got, test.want)
		}
	}
}

let testsGeometricMean: []meanTest = [
	{x: [], want: 0},
	{x: [2, 4, 6, 8, 10], want: 5.210342169394704},
	{x: [60, 90, 120], want: 86.53497421844448},
	{x: [0.5, 1.5, 2.5, 3.5], want: 1.6005429364718398},
	{x: [5, 5, 5, 10], want: 5.946035575013605},
]

#test
fn testGeometricMean(t: &testing::T) {
	for _, test in testsGeometricMean {
		got := GeometricMean(test.x)
		if !VeryClose(got, test.want) {
			t.Errorf("GeometricMean({}) = {}, expected {}", test.x, got, test.want)
		}
	}
}

let testsHarmonicMean: []meanTest = [
	{x: [], want: 0},
	{x: [2, 4, 6, 8, 10], want: 4.37956204379562},
	{x: [60, 90, 120], want: 83.076923076923087},
	{x: [0.5, 1.5, 2.5, 3.5], want: 1.1931818181818183},
	{x: [5, 5, 5, 10], want: 5.7142857142857135},
]

#test
fn testHarmonicMean(t: &testing::T) {
	for _, test in testsHarmonicMean {
		got := HarmonicMean(test.x)
		if !VeryClose(got, test.want) {
			t.Errorf("HarmonicMean({}) = {}, expected {}", test.x, got, test.want)
		}
	}
}