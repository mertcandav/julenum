// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/testing"

struct chiSquareTest {
	obs:  []f64
	exp:  []f64
	want: f64
}

let testsChiSquare: []chiSquareTest = [
	{
		obs: [10, 12, 8],
		exp: [10, 10, 10],
		want: 0.8,
	},
	{
		obs: [3, 4, 5],
		exp: [3, 4, 5],
		want: 0,
	},
	{
		obs: [0, 3, 0],
		exp: [0, 3, 1],
		want: 1,
	},
]

#test
fn testChiSquare(t: &testing::T) {
	for _, test in testsChiSquare {
		got := ChiSquare(test.obs, test.exp)
		if got != test.want {
			t.Errorf("ChiSquare({}, {}) = {}, expected {}", test.obs, test.exp, got, test.want)
		}
	}
}

let testsChiSquareDistance: []chiSquareTest = [
	{
		obs: [1, 2, 13, 5, 45, 23],
		exp: [67, 90, 18, 79, 24, 98],
		want: 133.55428601494035,
	},
	{
		obs: [91, 900, 78, 30, 602, 813],
		exp: [57, 49, 36, 759, 234, 928],
		want: 814.776999405035,
	},
	{
		obs: [0, 3, 0],
		exp: [0, 3, 0],
		want: 0,
	},
]

#test
fn testChiSquareDistance(t: &testing::T) {
	for _, test in testsChiSquareDistance {
		got := ChiSquareDistance(test.obs, test.exp)
		if got != test.want {
			t.Errorf("ChiSquareDistance({}, {}) = {}, expected {}", test.obs, test.exp, got, test.want)
		}
	}
}

struct meanTest {
	x:    []f64
	want: f64
}

let testsMean: []meanTest = [
	{x: [], want: 0},
	{x: [0, 0, 0], want: 0},
	{x: [1, 2, 3], want: 2},
	{x: [1, 2, 3], want: 2},
	{x: [-34, 34, 0, 4, 834, -34, 74], want: 125.42857142857143},
]

#test
fn testMean(t: &testing::T) {
	for _, test in testsMean {
		got := Mean(test.x)
		if got != test.want {
			t.Errorf("Mean({}) = {}, expected {}", test.x, got, test.want)
		}
	}
}

#test
fn testMeanWeight(t: &testing::T) {
	for _, test in testsMean {
		mut got := MeanWeight(test.x, nil)
		if got != test.want {
			t.Errorf("MeanWeight({}, nil) = {}, expected {}", test.x, got, test.want)
		}
		mut ones := make([]f64, len(test.x))
		for i in ones {
			ones[i] = 1
		}
		got = MeanWeight(test.x, ones)
		if got != test.want {
			t.Errorf("MeanWeight({}, ones) = {}, expected {}", test.x, got, test.want)
		}
	}
}

let testsGeometricMean: []meanTest = [
	{x: [], want: 0},
	{x: [2, 4, 6, 8, 10], want: 5.210342169394704},
	{x: [60, 90, 120], want: 86.53497421844448},
	{x: [0.5, 1.5, 2.5, 3.5], want: 1.6005429364718398},
	{x: [5, 5, 5, 10], want: 5.946035575013605},
]

#test
fn testGeometricMean(t: &testing::T) {
	for _, test in testsGeometricMean {
		got := GeometricMean(test.x)
		if !VeryClose(got, test.want) {
			t.Errorf("GeometricMean({}) = {}, expected {}", test.x, got, test.want)
		}
	}
}

#test
fn testGeometricMeanWeight(t: &testing::T) {
	for _, test in testsGeometricMean {
		mut got := GeometricMeanWeight(test.x, nil)
		if !VeryClose(got, test.want) {
			t.Errorf("GeometricMeanWeight({}, nil) = {}, expected {}", test.x, got, test.want)
		}
		mut ones := make([]f64, len(test.x))
		for i in ones {
			ones[i] = 1
		}
		got = GeometricMeanWeight(test.x, ones)
		if !VeryClose(got, test.want) {
			t.Errorf("GeometricMeanWeight({}, ones) = {}, expected {}", test.x, got, test.want)
		}
	}
}

let testsHarmonicMean: []meanTest = [
	{x: [], want: 0},
	{x: [2, 4, 6, 8, 10], want: 4.37956204379562},
	{x: [60, 90, 120], want: 83.076923076923087},
	{x: [0.5, 1.5, 2.5, 3.5], want: 1.1931818181818183},
	{x: [5, 5, 5, 10], want: 5.7142857142857135},
]

#test
fn testHarmonicMean(t: &testing::T) {
	for _, test in testsHarmonicMean {
		got := HarmonicMean(test.x)
		if !VeryClose(got, test.want) {
			t.Errorf("HarmonicMean({}) = {}, expected {}", test.x, got, test.want)
		}
	}
}

#test
fn testHarmonicMeanWeight(t: &testing::T) {
	for _, test in testsHarmonicMean {
		mut got := HarmonicMeanWeight(test.x, nil)
		if !VeryClose(got, test.want) {
			t.Errorf("HarmonicMeanWeight({}, nil) = {}, expected {}", test.x, got, test.want)
		}
		mut ones := make([]f64, len(test.x))
		for i in ones {
			ones[i] = 1
		}
		got = HarmonicMeanWeight(test.x, ones)
		if !VeryClose(got, test.want) {
			t.Errorf("HarmonicMeanWeight({}, ones) = {}, expected {}", test.x, got, test.want)
		}
	}
}

let testsRootMeanSquare: []meanTest = [
	{x: [], want: 0},
	{x: [3, 4], want: 3.5355339059327378},
	{x: [1, 2, 3, 4, 5], want: 3.3166247903554},
	{x: [-1, -2, -3, -4, -5], want: 3.3166247903554},
	{x: [10, 10, 10, 10], want: 10},
	{x: [0, 10], want: 7.0710678118654755},
	{x: [0.1, 0.2, 0.3], want: 0.21602468994692867},
	{x: [-3, 4], want: 3.5355339059327378},
	{x: [6, 8], want: 7.0710678118654755},
]

#test
fn testRootMeanSquare(t: &testing::T) {
	for _, test in testsRootMeanSquare {
		got := RootMeanSquare(test.x)
		if !VeryClose(got, test.want) {
			t.Errorf("RootMeanSquare({}) = {}, expected {}", test.x, got, test.want)
		}
	}
}

#test
fn testRootMeanSquareWeight(t: &testing::T) {
	for _, test in testsRootMeanSquare {
		mut got := RootMeanSquareWeight(test.x, nil)
		if !VeryClose(got, test.want) {
			t.Errorf("RootMeanSquareWeight({}, nil) = {}, expected {}", test.x, got, test.want)
		}
		mut ones := make([]f64, len(test.x))
		for i in ones {
			ones[i] = 1
		}
		got = RootMeanSquareWeight(test.x, ones)
		if !VeryClose(got, test.want) {
			t.Errorf("RootMeanSquareWeight({}, ones) = {}, expected {}", test.x, got, test.want)
		}
	}
}

let testsCircularMean: []meanTest = [
	{x: [], want: 0},
	{x: [3, 4], want: -2.7831853071795867},
	{x: [1, 2, 3, 4, 5], want: 3},
	{x: [-1, -2, -3, -4, -5], want: -3},
	{x: [10, 10, 10, 10], want: -2.566370614359173},
	{x: [0, 10], want: -1.2831853071795865},
	{x: [0.1, 0.2, 0.3], want: 0.19999999999999996},
	{x: [-3, 4], want: -2.641592653589793},
	{x: [6, 8], want: 0.7168146928204135},
]

#test
fn testCircularMean(t: &testing::T) {
	for _, test in testsCircularMean {
		got := CircularMean(test.x)
		if !VeryClose(got, test.want) {
			t.Errorf("CircularMean({}) = {}, expected {}", test.x, got, test.want)
		}
	}
}

#test
fn testCircularMeanWeight(t: &testing::T) {
	for _, test in testsCircularMean {
		mut got := CircularMeanWeight(test.x, nil)
		if !VeryClose(got, test.want) {
			t.Errorf("CircularMeanWeight({}, nil) = {}, expected {}", test.x, got, test.want)
		}
		mut ones := make([]f64, len(test.x))
		for i in ones {
			ones[i] = 1
		}
		got = CircularMeanWeight(test.x, ones)
		if !VeryClose(got, test.want) {
			t.Errorf("CircularMeanWeight({}, ones) = {}, expected {}", test.x, got, test.want)
		}
	}
}

let testsMedian: []meanTest = [
	{x: [1, 2, 3.3, 4], want: 2.65},
	{x: [1, 2, 3, 4], want: 2.5},
	{x: [1, 2, 3, 4, 5], want: 3},
	{x: [-2, -1, 0, 1, 2], want: 0},
	{x: [-2, -1, 1, 2], want: 0},
	{x: [-2, -1, 2, 2], want: 0.5},
	{x: [-100, 1], want: -49.5},
]

#test
fn testMedian(t: &testing::T) {
	for _, test in testsMedian {
		mut got := Median(test.x)
		if !VeryClose(got, test.want) {
			t.Errorf("Median({}) = {}, expected {}", test.x, got, test.want)
		}
	}
}

struct correlationTest {
	x:       []f64
	y:       []f64
	weights: []f64
	want:    f64
}

let testsCorrelation: []correlationTest = [
	{
		x: [],
		y: [],
		want: 0,
	},
	{
		x: [1, 2, 3, 4, 5, 6],
		y: [1, 2, 3, 4, 5, 6],
		want: 1,
	},
	{
		x: [1.1, 2.2, 3.3, 4.4, 5.5, 6.6],
		y: [1, 2, 3, 4, 5, 6],
		want: 1,
	},
	{
		x: [-1, -2, -3, -4, -5, -6],
		y: [1, 2, 3, 4, 5, 6],
		want: -1,
	},
	{
		x: [-1, -2, -3, -4, -5, -6],
		y: [1, 2, 3, 4, 5, 6],
		weights: [1, 1, 1, 1, 1, 1],
		want: -1,
	},
	{
		x: [1, 2, 334, 4, 5, 6],
		y: [1, 2, 333, 4, 52, 6],
		want: 0.9897970931668703,
	},
	{
		x: [1, 2, 334, 4, 5, 6],
		y: [1, 2, 333, 4, 52, 6],
		want: 0.9897970931668703,
	},
	{
		x: [8, -3, 7, 8, -4],
		y: [10, 15, 4, 5, -1],
		want: 0.009333466076905933,
	},
	{
		x: [8, 3, 7, 8, -4],
		y: [-10, -15, -4, -5, -1],
		want: -0.3089443513476705,
	},
	{
		x: [8, 3, 7, 8, -4],
		y: [-10, -15, -4, -5, -1],
		weights: [1, 4, 5, 10, 4],
		want: -0.15071708335614534,
	},
	{
		x: [8, -3, 7, 8, -4],
		y: [10, 15, 4, 5, -1],
		weights: [1, 3, 1, 2, 2],
		want: -0.13966633352688942,
	},
]

#test
fn testCorrelation(t: &testing::T) {
	for _, test in testsCorrelation {
		if len(test.weights) != 0 {
			continue
		}
		mut got := Correlation(test.x, test.y)
		if got != test.want {
			t.Errorf("Correlation({}, {}) = {}, expected {}", test.x, test.y, got, test.want)
		}
	}
}

#test
fn testCorrelationWeight(t: &testing::T) {
	for _, test in testsCorrelation {
		mut got := CorrelationWeight(test.x, test.y, test.weights)
		if got != test.want {
			t.Errorf("CorrelationWeight({}, {}, {}) = {}, expected {}", test.x, test.y, test.weights, got, test.want)
		}
	}
}

let testsVariance: []correlationTest = [
	{
		x: [8, -3, 7, 8, -4],
		want: 37.7,
	},
	{
		x: [1, 2, 3, 4, 5, 6],
		want: 3.5,
	},
	{
		x: [8, 3, 7, 8, 4],
		weights: [2, 1, 2, 1, 1],
		want: 4.2857142857142865,
	},
	{
		x: [1, 4, 9],
		weights: [1, 1.5, 1],
		want: 13.142857142857146,
	},
	{
		x: [1, 2, 3],
		weights: [1, 1.5, 1],
		want: 0.8,
	},
]

#test
fn testVariance(t: &testing::T) {
	for _, test in testsVariance {
		if len(test.weights) != 0 {
			continue
		}
		mut got := Variance(test.x)
		if !VeryClose(got, test.want) {
			t.Errorf("Variance({}) = {}, expected {}", test.x, got, test.want)
		}
	}
}

#test
fn testVarianceWeight(t: &testing::T) {
	for _, test in testsVariance {
		mut got := VarianceWeight(test.x, test.weights)
		if !VeryClose(got, test.want) {
			t.Errorf("VarianceWeight({}, {}) = {}, expected {}", test.x, test.weights, got, test.want)
		}
	}
}