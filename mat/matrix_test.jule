// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/testing"

#test
fn testMatrixIsZero(t: &testing::T) {
	mut x := New[int](0, 0)
	if !x.IsZero() {
		t.Errorf("IsZero() = false, when Dims() == (0, 0)")
	}
	x = New[int](2, 2)
	if !x.IsZero() {
		t.Errorf("IsZero() = false, when Dims() == (2, 2)")
	}
}

struct caseNewFrom {
	input: [][]int
	data:  []int
	m:     int
	n:     int
}

let testsNewFrom: []caseNewFrom = [
	{
		input: nil,
		data: [],
		m: 0,
		n: 0,
	},
	{
		input: [][]int([[], []]),
		data: [],
		m: 0,
		n: 0,
	},
	{
		input: [[1, 2, 4], [3, 4, 5]],
		data: [1, 2, 4, 3, 4, 5],
		m: 2,
		n: 3,
	},
	{
		input: [[1]],
		data: [1],
		m: 1,
		n: 1,
	},
	{
		input: [[1], [2], [3], [4]],
		data: [1, 2, 3, 4],
		m: 4,
		n: 1,
	},
	{
		input: [[1, 2], [2, 3], [3, 4], [4, 5]],
		data: [1, 2, 2, 3, 3, 4, 4, 5],
		m: 4,
		n: 2,
	},
	{
		input: [[1, 2, 3, 4, 5]],
		data: [1, 2, 3, 4, 5],
		m: 1,
		n: 5,
	},
]

#test
fn testNewFrom(t: &testing::T) {
	for _, test in testsNewFrom {
		mat := NewFrom(test.input)
		if mat.m != test.m || mat.n != test.n {
			t.Errorf("expected ({} x {}), found ({}, {}), for {}", test.m, test.n, mat.m, mat.n, test.input)
			continue
		}
		if len(mat.data) != len(test.data) {
			t.Errorf("data expected {}, found {}, for {}", test.data, mat.data, test.input)
			continue
		}
		for i in test.data {
			if test.data[i] != mat.data[i] {
				t.Errorf("data expected {}, found {}, for {}", test.data, mat.data, test.input)
				break
			}
		}
	}
}