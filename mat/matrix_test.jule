// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/testing"

#test
fn testMatrixGetSet(t: &testing::T) {
	mut x := New[f64](2, 2)
	x.Set(0, 0, 1)
	x.Set(0, 1, 3)
	x.Set(1, 0, 2)
	x.Set(1, 1, 4)
	if x.Get(0, 0) != 1 ||
		x.Get(0, 1) != 3 ||
		x.Get(1, 0) != 2 ||
		x.Get(1, 1) != 4 {
		t.Errorf("expected [1, 2, 3, 4], found {}", x.data)
	}
}

#test
fn testMatrixIsZero(t: &testing::T) {
	mut x := New[int](0, 0)
	if !x.IsZero() {
		t.Errorf("IsZero() = false, when Dims() == (0, 0)")
	}
	x = New[int](2, 2)
	if !x.IsZero() {
		t.Errorf("IsZero() = false, when Dims() == (2, 2)")
	}
}

struct caseNewFrom {
	input: [][]int
	data:  []int
	m:     int
	n:     int
}

let testsNewFrom: []caseNewFrom = [
	{
		input: nil,
		data: [],
		m: 0,
		n: 0,
	},
	{
		input: [][]int([[], []]),
		data: [],
		m: 0,
		n: 0,
	},
	{
		input: [[1, 2, 4], [3, 4, 5]],
		data: [1, 3, 2, 4, 4, 5],
		m: 2,
		n: 3,
	},
	{
		input: [[1]],
		data: [1],
		m: 1,
		n: 1,
	},
	{
		input: [[1], [2], [3], [4]],
		data: [1, 2, 3, 4],
		m: 4,
		n: 1,
	},
	{
		input: [[1, 2], [2, 3], [3, 4], [4, 5]],
		data: [1, 2, 3, 4, 2, 3, 4, 5],
		m: 4,
		n: 2,
	},
	{
		input: [[1, 2, 3, 4, 5]],
		data: [1, 2, 3, 4, 5],
		m: 1,
		n: 5,
	},
]

#test
fn testNewFrom(t: &testing::T) {
	for _, test in testsNewFrom {
		mat := NewFrom(test.input)
		if mat.m != test.m || mat.n != test.n {
			t.Errorf("expected ({} x {}), found ({}, {}), for {}", test.m, test.n, mat.m, mat.n, test.input)
			continue
		}
		if len(mat.data) != len(test.data) {
			t.Errorf("data expected {}, found {}, for {}", test.data, mat.data, test.input)
			continue
		}
		for i in test.data {
			if test.data[i] != mat.data[i] {
				t.Errorf("data expected {}, found {}, for {}", test.data, mat.data, test.input)
				break
			}
		}
	}
}

#test
fn testMatrixCopy(t: &testing::T) {
	mut a := NewFrom([
		[1, 2],
		[3, 4],
	])
	mut b := New[int](0, 0)
	b.Copy(&a)
	if alias(a.data, b.data) {
		t.Errorf("#1: expected independent copy, found shared allocation")
	}
	bdata := b.data
	b.Copy(&a)
	if !alias(b.data, bdata) {
		t.Errorf("#2: expected shared allocation, found new allocation")
	}
	a.Copy(&a)
	if !alias(a.data, a.data) {
		t.Errorf("#3: expected shared allocation, found new allocation")
	}
}

#test
fn testMatrixFill(t: &testing::T) {
	mut a := New[int](5, 5)
	a.Fill(&a, 8)
	for i in a.data {
		if a.data[i] != 8 {
			t.Errorf("data expected to be filled with 8, found {}", a.data)
			break
		}
	}
}

struct caseMatrixTrace {
	input: [][]int
	trace: int
}

let testsMatrixTrace: []caseMatrixTrace = [
	{
		input: [[1, 2], [3, 4]],
		trace: 5,
	},
	{
		input: [[1, 2, 4], [3, 4, 8], [0, 0, 8]],
		trace: 13,
	},
	{
		input: [[7, 1], [3, 5]],
		trace: 12,
	},
	{
		input: [[2, 9, 1], [4, -3, 6], [0, 8, 5]],
		trace: 4,
	},
	{
		input: [[-1, 2, 3], [4, 0, -5], [6, 7, -8]],
		trace: -9,
	},
]

#test
fn testMatrixTrace(t: &testing::T) {
	for _, test in testsMatrixTrace {
		m := NewFrom(test.input)
		trace := m.Trace()
		if trace != test.trace {
			t.Errorf("expected {}, found {}, for {}", test.trace, trace, test.input)
		}
	}
}