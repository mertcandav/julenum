// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/testing"

#test
fn testMatrixGetSet(t: &testing::T) {
	mut x := New[f64](2, 2)
	x.Set(0, 0, 1)
	x.Set(0, 1, 3)
	x.Set(1, 0, 2)
	x.Set(1, 1, 4)
	if x.Get(0, 0) != 1 ||
		x.Get(0, 1) != 3 ||
		x.Get(1, 0) != 2 ||
		x.Get(1, 1) != 4 {
		t.Errorf("expected [1, 2, 3, 4], found {}", x.data)
	}
}

#test
fn testMatrixIsZero(t: &testing::T) {
	mut x := New[int](0, 0)
	if !x.IsZero() {
		t.Errorf("IsZero() = false, when Dims() == (0, 0)")
	}
	x = New[int](2, 2)
	if !x.IsZero() {
		t.Errorf("IsZero() = false, when Dims() == (2, 2)")
	}
}

struct caseNewFrom {
	input: [][]int
	data:  []int
	m:     int
	n:     int
}

let testsNewFrom: []caseNewFrom = [
	{
		input: nil,
		data: [],
		m: 0,
		n: 0,
	},
	{
		input: [][]int([[], []]),
		data: [],
		m: 0,
		n: 0,
	},
	{
		input: [[1, 2, 4], [3, 4, 5]],
		data: [1, 3, 2, 4, 4, 5],
		m: 2,
		n: 3,
	},
	{
		input: [[1]],
		data: [1],
		m: 1,
		n: 1,
	},
	{
		input: [[1], [2], [3], [4]],
		data: [1, 2, 3, 4],
		m: 4,
		n: 1,
	},
	{
		input: [[1, 2], [2, 3], [3, 4], [4, 5]],
		data: [1, 2, 3, 4, 2, 3, 4, 5],
		m: 4,
		n: 2,
	},
	{
		input: [[1, 2, 3, 4, 5]],
		data: [1, 2, 3, 4, 5],
		m: 1,
		n: 5,
	},
]

#test
fn testNewFrom(t: &testing::T) {
	for _, test in testsNewFrom {
		mat := NewFrom(test.input)
		if mat.m != test.m || mat.n != test.n {
			t.Errorf("expected ({} x {}), found ({}, {}), for {}", test.m, test.n, mat.m, mat.n, test.input)
			continue
		}
		if len(mat.data) != len(test.data) {
			t.Errorf("data expected {}, found {}, for {}", test.data, mat.data, test.input)
			continue
		}
		for i in test.data {
			if test.data[i] != mat.data[i] {
				t.Errorf("data expected {}, found {}, for {}", test.data, mat.data, test.input)
				break
			}
		}
	}
}

#test
fn testMatrixCopy(t: &testing::T) {
	mut a := NewFrom([
		[1, 2],
		[3, 4],
	])
	mut b := New[int](0, 0)
	b.Copy(&a)
	if alias(a.data, b.data) {
		t.Errorf("#1: expected independent copy, found shared allocation")
	}
	bdata := b.data
	b.Copy(&a)
	if !alias(b.data, bdata) {
		t.Errorf("#2: expected shared allocation, found new allocation")
	}
	a.Copy(&a)
	if !alias(a.data, a.data) {
		t.Errorf("#3: expected shared allocation, found new allocation")
	}
}

#test
fn testMatrixFill(t: &testing::T) {
	mut a := New[int](5, 5)
	a.Fill(&a, 8)
	for i in a.data {
		if a.data[i] != 8 {
			t.Errorf("data expected to be filled with 8, found {}", a.data)
			break
		}
	}

	b := New[int](2, 2)
	a.Fill(&b, 42)
	if len(a.data) != len(b.data) {
		t.Errorf("data length expected {}, found {}", len(b.data), len(a.data))
	}
	for i in a.data {
		if a.data[i] != 42 {
			t.Errorf("data expected to be filled with 42, found {}", a.data)
			break
		}
	}
}

struct caseMatrixTrace {
	input: [][]int
	trace: int
}

let testsMatrixTrace: []caseMatrixTrace = [
	{
		input: [[1, 2], [3, 4]],
		trace: 5,
	},
	{
		input: [[1, 2, 4], [3, 4, 8], [0, 0, 8]],
		trace: 13,
	},
	{
		input: [[7, 1], [3, 5]],
		trace: 12,
	},
	{
		input: [[2, 9, 1], [4, -3, 6], [0, 8, 5]],
		trace: 4,
	},
	{
		input: [[-1, 2, 3], [4, 0, -5], [6, 7, -8]],
		trace: -9,
	},
]

#test
fn testMatrixTrace(t: &testing::T) {
	for _, test in testsMatrixTrace {
		m := NewFrom(test.input)
		trace := m.Trace()
		if trace != test.trace {
			t.Errorf("expected {}, found {}, for {}", test.trace, trace, test.input)
		}
	}
}

let testsMatrixTranspose: []caseNewFrom = [
	{
		input: nil,
		data: [],
		m: 0,
		n: 0,
	},
	{
		input: [][]int([[], []]),
		data: [],
		m: 0,
		n: 0,
	},
	{
		input: [[1, 2, 3], [4, 5, 6]],
		data: [1, 2, 3, 4, 5, 6],
		m: 3,
		n: 2,
	},
	{
		input: [[1]],
		data: [1],
		m: 1,
		n: 1,
	},
	{
		input: [[1], [2], [3], [4]],
		data: [1, 2, 3, 4],
		m: 1,
		n: 4,
	},
	{
		input: [[1, 2], [2, 3], [3, 4], [4, 5]],
		data: [1, 2, 2, 3, 3, 4, 4, 5],
		m: 2,
		n: 4,
	},
	{
		input: [[1, 2, 3, 4, 5]],
		data: [1, 2, 3, 4, 5],
		m: 5,
		n: 1,
	},
]

#test
fn testMatrixTranspose(t: &testing::T) {
	for _, test in testsMatrixTranspose {
		mut mat := NewFrom(test.input)
		mat.Transpose(&mat)
		if mat.m != test.m || mat.n != test.n {
			t.Errorf("expected ({} x {}), found ({}, {}), for {}", test.m, test.n, mat.m, mat.n, test.input)
			continue
		}
		if len(mat.data) != len(test.data) {
			t.Errorf("data expected {}, found {}, for {}", test.data, mat.data, test.input)
			continue
		}
		for i in test.data {
			if test.data[i] != mat.data[i] {
				t.Errorf("data expected {}, found {}, for {}", test.data, mat.data, test.input)
				break
			}
		}
	}
}

struct testMatrixScalar {
	input: [][]int
	data:  []int
	k:     int
}

fn testCaseMatrixScalar(t: &testing::T, tests: []testMatrixScalar, r: fn(test: testMatrixScalar): Matrix[int]) {
	for _, test in tests {
		mut mat := r(test)
		if len(mat.data) != len(test.data) {
			t.Errorf("data expected {}, found {}, for {}", test.data, mat.data, test.input)
			continue
		}
		for i in test.data {
			if test.data[i] != mat.data[i] {
				t.Errorf("data expected {}, found {}, for {}", test.data, mat.data, test.input)
				break
			}
		}
	}
}

let testsMatrixMulScalar: []testMatrixScalar = [
	{
		input: nil,
		data: [],
		k: 0,
	},
	{
		input: [][]int([[], []]),
		data: [],
		k: 0,
	},
	{
		input: [[1, 2, 4], [3, 4, 5]],
		data: [2, 6, 4, 8, 8, 10],
		k: 2,
	},
	{
		input: [[1]],
		data: [10],
		k: 10,
	},
	{
		input: [[1], [2], [3], [4]],
		data: [-1, -2, -3, -4],
		k: -1,
	},
	{
		input: [[1, 2], [2, 3], [3, 4], [4, 5]],
		data: [1, 2, 3, 4, 2, 3, 4, 5],
		k: 1,
	},
	{
		input: [[1, 2, 3, 4, 5]],
		data: [3, 6, 9, 12, 15],
		k: 3,
	},
	{
		input: [[1, 2], [2, 3], [3, 4], [4, 5]],
		data: [0, 0, 0, 0, 0, 0, 0, 0],
		k: 0,
	},
]

#test
fn testMatrixMulScalar(t: &testing::T) {
	testCaseMatrixScalar(t, testsMatrixMulScalar, fn|test| {
		mut mat := NewFrom(test.input)
		mat.MulScalar(&mat, test.k)
		ret mat
	})
}

let testsMatrixAddScalar: []testMatrixScalar = [
	{
		input: nil,
		data: [],
		k: 0,
	},
	{
		input: [][]int([[], []]),
		data: [],
		k: 0,
	},
	{
		input: [[1, 2, 4], [3, 4, 5]],
		data: [3, 5, 4, 6, 6, 7],
		k: 2,
	},
	{
		input: [[1]],
		data: [2],
		k: 1,
	},
	{
		input: [[1], [2], [3], [4]],
		data: [4, 5, 6, 7],
		k: 3,
	},
	{
		input: [[1, 2], [2, 3], [3, 4], [4, 5]],
		data: [-8, -7, -6, -5, -7, -6, -5, -4],
		k: -9,
	},
	{
		input: [[1, 2], [2, 3], [3, 4], [4, 5]],
		data: [1, 2, 3, 4, 2, 3, 4, 5],
		k: 0,
	},
	{
		input: [[1, 2, 3, 4, 5]],
		data: [0, 1, 2, 3, 4],
		k: -1,
	},
]

#test
fn testMatrixAddScalar(t: &testing::T) {
	testCaseMatrixScalar(t, testsMatrixAddScalar, fn|test| {
		mut mat := NewFrom(test.input)
		mat.AddScalar(&mat, test.k)
		ret mat
	})
}

let testsMatrixSubScalar: []testMatrixScalar = [
	{
		input: nil,
		data: [],
		k: 0,
	},
	{
		input: [][]int([[], []]),
		data: [],
		k: 0,
	},
	{
		input: [[1, 2, 4], [3, 4, 5]],
		data: [-1, 1, 0, 2, 2, 3],
		k: 2,
	},
	{
		input: [[1]],
		data: [0],
		k: 1,
	},
	{
		input: [[1], [2], [3], [4]],
		data: [-2, -1, 0, 1],
		k: 3,
	},
	{
		input: [[1, 2], [2, 3], [3, 4], [4, 5]],
		data: [1, 2, 3, 4, 2, 3, 4, 5],
		k: 0,
	},
	{
		input: [[1, 2], [2, 3], [3, 4], [4, 5]],
		data: [2, 3, 4, 5, 3, 4, 5, 6],
		k: -1,
	},
	{
		input: [[1, 2, 3, 4, 5]],
		data: [101, 102, 103, 104, 105],
		k: -100,
	},
]

#test
fn testMatrixSubScalar(t: &testing::T) {
	testCaseMatrixScalar(t, testsMatrixSubScalar, fn|test| {
		mut mat := NewFrom(test.input)
		mat.SubScalar(&mat, test.k)
		ret mat
	})
}