// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/math"

// Size of a uint in bits.
const uintSize = 32 << (^uint(0) >> 63) // 32 or 64

// A matrix for type T.
// Uses internal mutable slice to store data.
// Matrix computations may use available capacity of the underlying slice
// to avoid making new allocation. So shared data needs extra attention.
// Any mutable operation may be reflected to shared common data.
// If you need to share same Matrix instance, use smart pointers.
// If you need to have guaranteed independent copy, use Copy with empty Matrix.
struct Matrix[T: numeric] {
	// Dimensions (M x N).
	m: int
	n: int

	// Data array, column-major.
	data: []T
}

impl Matrix {
	// Returns dimensions of the Matrix (M x N).
	fn Dims(*self): (m: int, n: int) {
		ret self.m, self.n
	}

	// Returns total element count of matrix (M x N).
	fn Size(*self): int {
		ret self.m * self.n
	}

	// Reports whether the all values of Matrix are zero.
	//
	// Special cases are:
	//	Zero() = true, if Dims() == (0, 0)
	fn Zero(*self): bool {
		for _, x in self.data {
			if x != 0 {
				ret false
			}
		}
		ret true
	}

	// Reports whether the Matrix is a square matrix (M == N).
	fn Square(*self): bool {
		ret self.m == self.n
	}

	// Reports whether the matrice (M X N) is scalar matrice of c.
	// This function only supports square matrices (M == N && N > 0).
	#disable boundary
	fn Scalar(*self, c: T): bool {
		if self.m != self.n || self.n <= 0 {
			panic("mat: Matrix.Scalar: determinant on non-square matrix")
		}
		mut i := 0
		mut j := 0 // 0 + i*self.m
		for i < self.n; i++ {
			mut k := j         // Start position of the column i.
			mut pivot := k + i // Pivot index for the c element.
			j += self.m        // Point to the index of the next column of matrix.
			for k < j; k++ {
				if k == pivot {
					if self.data[k] != c {
						ret false
					}
				} else if self.data[k] != 0 {
					ret false
				}
			}
		}
		ret true
	}

	// Reports whether the matrice (M X N) is an identity matrice.
	// This function only supports square matrices (M == N && N > 0).
	fn Identity(*self): bool {
		ret self.Scalar(1)
	}

	// Reports whether the matrice (M X N) is a diagonal matrice.
	// This function only supports square matrices (M == N && N > 0).
	fn Diagonal(*self): bool {
		if self.m != self.n || self.n <= 0 {
			panic("mat: Matrix.Diagonal: determinant on non-square matrix")
		}
		mut i := 0
		mut j := 0 // 0 + i*self.m
		for i < self.n; i++ {
			mut k := j         // Start position of the column i.
			mut pivot := k + i // Pivot index for the c element.
			j += self.m        // Point to the index of the next column of matrix.
			for k < j; k++ {
				if k == pivot {
					if self.data[k] == 0 {
						ret false
					}
				} else if self.data[k] != 0 {
					ret false
				}
			}
		}
		ret true
	}

	// Returns value of the specified (i x j) position.
	// Position index starts from zero for column and row.
	//
	// Implementation will not check for boundaries, invalid position may cause panic.
	// To provide fast computation, it will not check whether the (i x j) is valid (M x N).
	fn Get(*self, i: int, j: int): T {
		ret self.data[i+j*self.m]
	}

	// Sets value of the specified (i x j) position.
	// Position index starts from zero for column and row.
	//
	// Implementation will not check for boundaries, invalid position may cause panic.
	// To provide fast computation, it will not check whether the (i x j) is valid (M x N).
	fn Set(mut *self, i: int, j: int, value: T) {
		self.data[i+j*self.m] = value
	}

	// Reports whether self and z matrices are equal.
	#disable boundary
	fn Equal(*self, &z: *Matrix[T]): bool {
		if self.m != z.m || self.n != z.n {
			ret false
		}
		mut i := 0
		for i < len(self.data); i++ {
			if self.data[i] != z.data[i] {
				ret false
			}
		}
		ret true
	}

	// Returns new buffer enough to store at least n values.
	fn make(mut *self, n: int): []T {
		// Reuse self capacity, if there is enough space.
		if n <= cap(self.data) {
			ret self.data[:n]
		}
		ret make([]T, n)
	}

	// Returns the sum of the elements of the matrix.
	// Matrix should be (M x N), where M and N > 0.
	fn Sum(*self): T {
		if self.m < 1 || self.n < 1 {
			panic("mat: Matrix.Sum: M < 1 || N < 1")
		}
		let mut sum: T
		for _, x in self.data {
			sum += x
		}
		ret sum
	}

	// Returns the smallest element value of the matrix.
	// Matrix should be (M x N), where M and N > 0.
	#disable boundary
	fn Min(*self): T {
		if self.m < 1 || self.n < 1 {
			panic("mat: Matrix.Min: M < 1 || N < 1")
		}
		mut min := self.data[0]
		mut i := 1
		for i < len(self.data); i++ {
			x := self.data[i]
			if min > x {
				min = x
			}
		}
		ret min
	}

	// Returns the largest element value of the matrix.
	// Matrix should be (M x N), where M and N > 0.
	#disable boundary
	fn Max(*self): T {
		if self.m < 1 || self.n < 1 {
			panic("mat: Matrix.Max: M < 1 || N < 1")
		}
		mut max := self.data[0]
		mut i := 1
		for i < len(self.data); i++ {
			x := self.data[i]
			if max < x {
				max = x
			}
		}
		ret max
	}

	// Sets self to z, filled with k.
	// If self have enough capacity, Fill will use it to avoid making allocation.
	#disable boundary
	fn Fill(mut *self, &z: *Matrix[T], k: T) {
		// Make sure the self data have enough space.
		self.m, self.n = z.m, z.n
		self.data = self.make(self.Size())

		mut i := 0
		for i < len(z.data); i++ {
			self.data[i] = k
		}
	}

	// Copies z to self.
	//
	// If self have enough capacity, Copy will use it to avoid making allocation.
	fn Copy(mut *self, &z: *Matrix[T]) {
		// Fast case: if z and self is the same pointer.
		if self == z {
			ret
		}

		// Make sure the self data have enough space.
		self.m, self.n = z.m, z.n
		self.data = self.make(self.Size())

		copy(self.data, z.data)
	}

	// Copies matrice z to self with custom (M x N) size.
	// If new size is larger, it will add padding with zeros.
	// If new size is smaller, it will cut rows and columns.
	//
	// If self have enough capacity, Resize will use it to avoid making allocation.
	// If M == 0 or N == 0, self will be (0 x 0). But keeps internal allocation.
	fn Resize(mut *self, &z: *Matrix[T], m: int, n: int) {
		if m == 0 || n == 0 {
			self.data = self.data[:0]
			self.m, self.n = 0, 0
			ret
		}

		// Same size, copy directly.
		if self.m == m && self.n == n {
			// If z and self is the same pointer, avoid copying cost.
			if self != z {
				copy(self.data, z.data)
			}
			ret
		}
		// Size is different, resize the matrix.

		let mut copySpace: []T
		if alias(self.data, z.data) {
			// Matrix self and matrix z have shared data.
			// We have to allocate new (M x N) Matrix to copy properly.
			copySpace = make([]T, m*n)
		} else {
			copySpace = self.make(m * n)
		}

		mut r := Matrix[T]{
			m: m,
			n: n,
			data: copySpace,
		}

		// New size is larger than old.
		if m >= self.m && n >= self.n {
			padAndCopy(&r, z)
		} else {
			// New size is smaller than old.
			copySubMatrix(&r, z, 0, 0, m, n)
		}

		*self = r
	}

	// Returns trace of matrix.
	// Panics if matrix is not a square matrix.
	//
	// Special cases are:
	//	Trace() = 0, for (0 x 0) matrices
	#disable boundary
	fn Trace(*self): T {
		if self.m != self.n {
			panic("mat: Matrix.Trace: trace computation on non-square matrix")
		}
		// Special case: trace of (0 x 0) matrix.
		if self.m == 0 {
			ret 0
		}
		// Compute trace of self.

		mut n := self.data[0]
		mut i := 1
		mut k := i + self.m // i + i*self.m
		for i < self.m; i, k = i+1, k+self.m+1 {
			n += self.data[k]
		}
		ret n
	}

	// Sets self to the transpose of the matrix z.
	// If self have enough capacity, Transpose will use it to avoid making allocation.
	// If z is a (0 x 0) matrix, self will be (0 x 0). But keeps internal allocation.
	#disable boundary
	fn Transpose(mut *self, &z: *Matrix[T]) {
		// Special case: (0 x 0) matrix.
		// Set self to (0 x 0), do not deallocate slice.
		if z.m == 0 && z.n == 0 {
			self.m, self.n = 0, 0
			ret
		}

		// (M x N) matrix will become (N x M).
		// So size will not be changed.
		// Make sure the self data have enough space.
		if self == z || alias(self.data, z.data) {
			// Matrix self and matrix z have shared data.
			// We have to allocate new (N x M) Matrix to compute properly.
			mut r := uncheckedNew[T](z.n, z.m)
			r.Transpose(z)
			*self = r
			ret
		} else {
			self.m, self.n = z.n, z.m
			self.data = self.make(self.Size())
		}
		// Compute transpose of z.

		mut i := 0
		mut zm := 0 + 0*z.m // j + i*z.m
		for i < z.n; i, zm = i+1, zm+z.m {
			mut sm := i + 0*self.m // i + j*self.m
			mut j := 0
			for j < z.m; j, sm = j+1, sm+self.m {
				self.data[sm] = z.data[j+zm]
			}
		}
	}

	// Sets self to the sum z+k.
	// If self have enough capacity, AddScalar will use it to avoid making allocation.
	// If z is a (0 x 0) matrix, self will be (0 x 0). But keeps internal allocation.
	#disable boundary
	fn AddScalar(mut *self, &z: *Matrix[T], k: T) {
		// Special case: (0 x 0) matrix.
		// Set self to (0 x 0), do not deallocate slice.
		if z.m == 0 && z.n == 0 {
			self.m, self.n = 0, 0
			ret
		}

		// Make sure the self data have enough space.
		self.m, self.n = z.m, z.n
		self.data = self.make(self.Size())
		// Compute z+k.

		// Special case: k is zero. Result will always be same matrix.
		// Copy data instead of scalar addition.
		if k == 0 {
			copy(self.data, z.data)
			ret
		}

		mut i := 0
		for i < len(self.data); i++ {
			self.data[i] = z.data[i] + k
		}
	}

	// Sets self to the difference z-k.
	// If self have enough capacity, SubScalar will use it to avoid making allocation.
	// If z is a (0 x 0) matrix, self will be (0 x 0). But keeps internal allocation.
	#disable boundary
	fn SubScalar(mut *self, &z: *Matrix[T], k: T) {
		self.AddScalar(z, -k)
	}

	// Sets self to the product z*k.
	// If self have enough capacity, MulScalar will use it to avoid making allocation.
	// If z is a (0 x 0) matrix, self will be (0 x 0). But keeps internal allocation.
	#disable boundary
	fn MulScalar(mut *self, &z: *Matrix[T], k: T) {
		// Special case: (0 x 0) matrix.
		// Set self to (0 x 0), do not deallocate slice.
		if z.m == 0 && z.n == 0 {
			self.m, self.n = 0, 0
			ret
		}

		// Special case: k is zero. Result will always be zero matrix.
		// Use Fill instead of scalar multiplication.
		if k == 0 {
			self.Fill(z, k)
			ret
		}

		// Make sure the self data have enough space.
		self.m, self.n = z.m, z.n
		self.data = self.make(self.Size())
		// Compute z*k.

		// Special case: k is one. Result will always be same matrix.
		// Copy data instead of scalar multiplication.
		if k == 1 {
			copy(self.data, z.data)
			ret
		}

		mut i := 0
		for i < len(self.data); i++ {
			self.data[i] = z.data[i] * k
		}
	}

	// Sets self to the sum x+y.
	// If self have enough capacity, Add will use it to avoid making allocation.
	// If matrices are (0 x 0) matrix, self will be (0 x 0). But keeps internal allocation.
	#disable boundary
	fn Add(mut *self, &x: *Matrix[T], &y: *Matrix[T]) {
		if x.m != y.m || x.n != y.n {
			panic("mat: Matrix.Add: matrices have different size")
		}

		// Special case: (0 x 0) matrix.
		// Set self to (0 x 0), do not deallocate slice.
		if x.m == 0 && x.n == 0 {
			self.m, self.n = 0, 0
			ret
		}

		// Make sure the self data have enough space.
		self.m, self.n = x.m, x.n
		self.data = self.make(self.Size())

		addRaw(self, x, y)
	}

	// Sets self to the difference x-y.
	// If self have enough capacity, Sub will use it to avoid making allocation.
	// If matrices are (0 x 0) matrix, self will be (0 x 0). But keeps internal allocation.
	#disable boundary
	fn Sub(mut *self, &x: *Matrix[T], &y: *Matrix[T]) {
		if x.m != y.m || x.n != y.n {
			panic("mat: Matrix.Sub: matrices have different size")
		}

		// Special case: (0 x 0) matrix.
		// Set self to (0 x 0), do not deallocate slice.
		if x.m == 0 && x.n == 0 {
			self.m, self.n = 0, 0
			ret
		}

		// Make sure the self data have enough space.
		self.m, self.n = x.m, x.n
		self.data = self.make(self.Size())

		subRaw(self, x, y)
	}

	// Sets self to the product x*y.
	// If self have enough capacity, Mul will use it to avoid making allocation.
	#disable boundary
	fn Mul(mut *self, &x: *Matrix[T], &y: *Matrix[T]) {
		if x.m < 1 || x.n < 1 ||
			y.m < 1 || y.n < 1 {
			panic("mat: Matrix.Mul: matrices must have at least (1 x 1) size")
		}
		if x.n != y.m {
			panic("mat: Matrix.Mul: dimensions are not compatible for multiplication")
		}
		// Compute x*y.

		// Use basic multiplication if matrices are small.
		n := max(max(x.m, x.n), y.n)
		if n < strassenThreshold {
			// self is an alias for x or y - cannot reuse.
			// We have to allocate new Matrix to compute properly.
			if self == x || self == y ||
				alias(self.data, x.data) || alias(self.data, y.data) {
				mut r := uncheckedNew[T](x.m, y.n)
				basicMul(&r, x, y)
				*self = r
				ret
			}

			// Make sure the self data have enough space.
			self.m, self.n = x.m, y.n
			self.data = self.make(self.Size())

			basicMul(self, x, y)
			ret
		}
		// Matrices are big for basic multiplication.
		// Use Strassen algorithm to compute efficiently.
		// https://en.wikipedia.org/wiki/Strassen_algorithm

		// Determine smallest power-of-two dimension to pad matrices to.
		// Ensures Strassen recursion works correctly.
		k := nextPowerOfTwo(n)

		// Total common buffer allocation size estimation for Strassen implementation:
		// Let n = size
		// - Padded matrices (worst case): 3n² (A, B, and C)
		// - Recursive temporary space per level: 17 × (n/2)^2 = (17/4) × n²
		// - Depth of recursion: log₂(n / threshold)
		// - Recursive workspace total:
		//   S(n) = (17/4)n² + (17/4)(n/2)² + ... + (17/4)(threshold)²
		//   This is a geometric series: S ≈ (17/3) × n²   (as n → ∞)
		// => Total = 3n² + (17/3)n² = (26/3)n² ≈ 8.67n²
		// We use a conservative multiplier of 9 to ensure no overflow at threshold=64.
		mut strassenSize := 9 * k * k

		// Determine whether the input matrices needs padding.
		xPadNeed := !isPowerOfTwo(x.m) || !isPowerOfTwo(x.n)
		yPadNeed := !isPowerOfTwo(y.m) || !isPowerOfTwo(y.n)

		// Remove size of the matrices, if it does not need padding.
		// It helps to reduce size of the common buffer allocation.
		if !xPadNeed {
			strassenSize -= x.m * x.n
		}
		if !yPadNeed {
			strassenSize -= y.m * y.n
		}

		// strassenSpace is a single buffer to compute x*y with Strassen algorithm.
		// It will be used for internal matrix data and the final matrix.
		// Once allocated, it will be used for the whole computation, no extra allocation.
		let mut strassenSpace: []T
		if self == x || self == y ||
			alias(self.data, x.data) || alias(self.data, y.data) {
			// self is an alias for x or y - cannot reuse.
			// We have to allocate new Matrix to compute properly.
			strassenSpace = make([]T, strassenSize)
		} else if cap(self.data) >= strassenSize {
			// In this case, we have enough slice capacity or length to store result.
			// To avoid making allocation, use the full capacity if needed.
			strassenSpace = self.data[:strassenSize]
		} else {
			// No enough space, we have to allocate new slice.
			strassenSpace = make([]T, strassenSize)
		}

		// Allocate z first to get end of the space.
		// It is important to save whole buffer allocation.
		// In the final stage, we will keep allocation for the result.
		// For the next computation, this buffer will be available.
		// To achieve that, the result matrix will be copied from the head of this allocation.
		// The z matrix will be result with possible padding.
		// To avoid collision during the copy, use the trailing space for z.
		zpos := len(strassenSpace) - k*k
		mut z := Matrix[T]{
			m: k,
			n: k,
			data: strassenSpace[zpos:],
		}
		strassenSpace = strassenSpace[:zpos]
		mut r := strassenSpace[:x.m*y.n] // The final result allocation.

		// Allocate padded matrices from common buffer, if needed.
		let mut xPad: Matrix[T]
		let mut yPad: Matrix[T]
		if xPadNeed {
			// Copy input matrices into zero-padded square matrices.
			xPad = getMatrix(k, k, &strassenSpace)
			padAndCopy(&xPad, x)
		} else {
			xPad = unsafe { **(&x) } // Break immutability, it will not be mutated.
		}
		if yPadNeed {
			// Copy input matrices into zero-padded square matrices.
			yPad = getMatrix(k, k, &strassenSpace)
			padAndCopy(&yPad, y)
		} else {
			yPad = unsafe { **(&y) } // Break immutability, it will not be mutated.
		}

		// Time to compute the product x*y using Strassen algorithm.
		strassen(&z, &xPad, &yPad, strassenSpace)

		// Set result to self.
		self.m, self.n = x.m, y.n
		self.data = r

		// The z matrix is the raw result now.
		// If it have same size with the actual result matrix, copy data directly.
		// Otherwise, extract resulting matrix from top-left of padded output.
		if z.m == self.m && z.n == self.n {
			copy(self.data, z.data)
		} else {
			mut sm := 0 + 0*self.m // i + j*self.m
			mut zm := 0 + 0*z.m    // i + j*z.m
			mut j := 0
			for j < self.n; j, sm, zm = j+1, sm+self.m, zm+z.m {
				mut i := 0
				for i < self.m; i++ {
					// Fast access form of: self.Set(i, j, z.Get(i, j))
					self.data[i+sm] = z.data[i+zm]
				}
			}
		}
	}

	// Computes the determinant of the matrix.
	// This function only supports square matrices (M == N && N > 0).
	#disable boundary
	fn Det(*self): f64 {
		m, n := self.m, self.n
		if m != n || n <= 0 {
			panic("mat: Matrix.Det: determinant on non-square matrix")
		}

		// Use direct formulas for small matrices.
		match n {
		| 1:
			// 1×1 matrix: det(A) = a₀₀
			ret f64(self.data[0])
		| 2:
			// 2×2 matrix:
			// det(A) = a₀₀·a₁₁ - a₀₁·a₁₀
			a_00 := f64(self.data[0+0*m])
			a_11 := f64(self.data[1+1*m])
			a_01 := f64(self.data[0+1*m])
			a_10 := f64(self.data[1+0*m])
			ret a_00*a_11 - a_01*a_10
		| 3:
			// 3×3 matrix using cofactor expansion along the first row:
			// det(A) = a₀₀·(a₁₁·a₂₂ - a₁₂·a₂₁)
			//        - a₀₁·(a₁₀·a₂₂ - a₁₂·a₂₀)
			//        + a₀₂·(a₁₀·a₂₁ - a₁₁·a₂₀)
			a_00 := f64(self.data[0+0*m])
			a_11 := f64(self.data[1+1*m])
			a_22 := f64(self.data[2+2*m])
			a_12 := f64(self.data[1+2*m])
			a_21 := f64(self.data[2+1*m])
			a_01 := f64(self.data[0+1*m])
			a_10 := f64(self.data[1+0*m])
			a_20 := f64(self.data[2+0*m])
			a_02 := f64(self.data[0+2*m])
			ret a_00*(a_11*a_22-a_12*a_21) -
				a_01*(a_10*a_22-a_12*a_20) +
				a_02*(a_10*a_21-a_11*a_20)
		}

		// Use LU decomposition with partial pivoting for larger ones.
		// See: https://en.wikipedia.org/wiki/LU_decomposition
		//
		// For general n×n matrices (n > 3), we use LU decomposition with partial pivoting:
		// If A = P·L·U, then det(A) = det(P)·det(L)·det(U)
		// - det(L) = 1 (L is unit lower triangular)
		// - det(U) = ∏ Uᵢᵢ
		// - det(P) = (−1)^s, where s is the number of row swaps (sign of permutation)

		mut LU := make([]f64, self.Size())
		for i in LU {
			LU[i] = f64(self.data[i])
		}

		// Tracks the sign of the determinant due to row swaps.
		mut detSign := 1.0

		mut k := 0
		mut km := 0 * m // k * m
		for k < n; k, km = k+1, km+m {
			// Pivot selection: find the row with the largest absolute value in column k.
			mut pivotIndex := k
			mut maxPivot := math::Abs(LU[k+km])
			mut i := k + 1
			for i < n; i++ {
				val := math::Abs(LU[i+km])
				if val > maxPivot {
					maxPivot = val
					pivotIndex = i
				}
			}

			// If the pivot is too small, matrix is singular or nearly singular.
			if maxPivot == 0 {
				ret 0
			}

			// Swap rows k and pivotIndex if necessary.
			if pivotIndex != k {
				mut j := 0
				mut jm := 0 * m // j * m
				for j < n; j, jm = j+1, jm+m {
					LU[k+jm], LU[pivotIndex+jm] = LU[pivotIndex+jm], LU[k+jm]
				}
				detSign = -detSign
			}

			pivot := LU[k+km]

			// Elimination: store multipliers in lower triangle, update submatrix.
			i = k + 1
			for i < n; i++ {
				LU[i+km] /= pivot
				factor := LU[i+km]
				mut j := k + 1
				mut jm := j * m
				for j < n; j, jm = j+1, jm+m {
					LU[i+jm] -= factor * LU[k+jm]
				}
			}
		}

		// Compute determinant: product of diagonal entries of U scaled by the permutation sign.
		mut det := detSign
		mut i := 0
		k = 0 + 0*m // i + i*m
		for i < n; i, k = i+1, k+m+1 {
			det *= LU[k]
		}
		ret det
	}

	// Computes the sign and natural logarithm of the absolute value of the determinant of the matrix.
	// Returns (sign, logdet). If the matrix is singular, returns (0, -Inf).
	// This function only supports square matrices (M == N && N > 0).
	//
	// NOTICE
	//	Let (sign, logdet) = Slogdet()
	//	- Mathematically: Det() = sign * exp(logdet)
	//	- In practice:    Det() ≈ sign * exp(logdet)
	//	                  due to floating-point rounding.
	#disable boundary
	fn Slogdet(*self): (sign: f64, logdet: f64) {
		m, n := self.m, self.n
		if m != n || n <= 0 {
			panic("mat: Matrix.Slogdet: determinant on non-square matrix")
		}

		// Use direct formulas for small matrices.
		match n {
		| 1:
			// 1×1 matrix: det(A) = a₀₀
			det := f64(self.data[0])
			if det == 0 {
				ret 0, math::Inf(-1)
			}
			ret math::Copysign(1, det), math::Log(math::Abs(det))
		| 2:
			// 2×2 matrix:
			// det(A) = a₀₀·a₁₁ - a₀₁·a₁₀
			a_00 := f64(self.data[0+0*m])
			a_11 := f64(self.data[1+1*m])
			a_01 := f64(self.data[0+1*m])
			a_10 := f64(self.data[1+0*m])
			det := a_00*a_11 - a_01*a_10
			if det == 0 {
				ret 0, math::Inf(-1)
			}
			ret math::Copysign(1, det), math::Log(math::Abs(det))
		| 3:
			// 3×3 matrix using cofactor expansion along the first row:
			// det(A) = a₀₀·(a₁₁·a₂₂ - a₁₂·a₂₁)
			//        - a₀₁·(a₁₀·a₂₂ - a₁₂·a₂₀)
			//        + a₀₂·(a₁₀·a₂₁ - a₁₁·a₂₀)
			a_00 := f64(self.data[0+0*m])
			a_11 := f64(self.data[1+1*m])
			a_22 := f64(self.data[2+2*m])
			a_12 := f64(self.data[1+2*m])
			a_21 := f64(self.data[2+1*m])
			a_01 := f64(self.data[0+1*m])
			a_10 := f64(self.data[1+0*m])
			a_20 := f64(self.data[2+0*m])
			a_02 := f64(self.data[0+2*m])
			det := a_00*(a_11*a_22-a_12*a_21) -
				a_01*(a_10*a_22-a_12*a_20) +
				a_02*(a_10*a_21-a_11*a_20)
			if det == 0 {
				ret 0, math::Inf(-1)
			}
			ret math::Copysign(1, det), math::Log(math::Abs(det))
		}

		// Use LU decomposition with partial pivoting for larger ones.
		// See: https://en.wikipedia.org/wiki/LU_decomposition
		//
		// For general n×n matrices (n > 3), we use LU decomposition with partial pivoting:
		// If A = P·L·U, then det(A) = det(P)·det(L)·det(U)
		// - det(L) = 1 (L is unit lower triangular)
		// - det(U) = ∏ Uᵢᵢ
		// - det(P) = (−1)^s, where s is the number of row swaps (sign of permutation)

		mut LU := make([]f64, self.Size())
		for i in LU {
			LU[i] = f64(self.data[i])
		}

		sign = 1.0 // Tracks the sign of the determinant due to row swaps.
		logdet = 0

		mut k := 0
		mut km := 0 * m // k * m
		for k < n; k, km = k+1, km+m {
			// Pivot selection: find the row with the largest absolute value in column k.
			mut pivotIndex := k
			mut maxPivot := math::Abs(LU[k+km])
			mut i := k + 1
			for i < n; i++ {
				val := math::Abs(LU[i+km])
				if val > maxPivot {
					maxPivot = val
					pivotIndex = i
				}
			}

			// If the pivot is too small, matrix is singular or nearly singular.
			if maxPivot == 0 {
				ret 0, math::Inf(-1)
			}

			// Swap rows k and pivotIndex if necessary.
			if pivotIndex != k {
				mut j := 0
				mut jm := 0 * m // j * m
				for j < n; j, jm = j+1, jm+m {
					LU[k+jm], LU[pivotIndex+jm] = LU[pivotIndex+jm], LU[k+jm]
				}
				sign = -sign
			}

			pivot := LU[k+km]
			logdet += math::Log(math::Abs(pivot))
			sign *= math::Copysign(1, pivot)

			// Elimination: store multipliers in lower triangle, update submatrix.
			i = k + 1
			for i < n; i++ {
				LU[i+km] /= pivot
				factor := LU[i+km]
				mut j := k + 1
				mut jm := j * m
				for j < n; j, jm = j+1, jm+m {
					LU[i+jm] -= factor * LU[k+jm]
				}
			}
		}

		ret
	}
}

// Same as New, but it does not checks anything.
fn uncheckedNew[T: numeric](m: int, n: int): Matrix[T] {
	let mut mat: Matrix[T]
	mat.m, mat.n = m, n
	mat.data = make([]T, m*n)
	ret mat
}

// Returns new empty (0 x 0) Matrix for type T.
fn Empty[T: numeric](): Matrix[T] {
	ret uncheckedNew[T](0, 0)
}

// Returns new (M x N) zero Matrix for type T.
//
// Constraints:
//	m >= 0
//	n >= 0
fn New[T: numeric](m: int, n: int): Matrix[T] {
	if m < 0 || n < 0 {
		panic("mat: New: m < 0 || n < 0")
	}
	ret uncheckedNew[T](m, n)
}

// Returns new (M x N) Matrix for type T.
// Uses len(values) for m, len(values[1]) for n.
// Panics if all rows are not have same amount of values.
//
// Special cases are:
//	NewFrom(values) = (0 x 0) Matrix, if len(values) == 0
//	NewFrom(values) = (0 x 0) Matrix, if len(values) == 1 && len(values[1]) == 0
//
// Example Use:
//
//	mat::NewFrom([
//		[1, 2, 4],
//		[3, 4, 5],
//	])
//
//	Equals to:
//		    ╭       ╮
//		    │ 1 2 4 │
//		A = │ 3 4 5 │
//		    ╰       ╯(2 x 3)
#disable boundary
fn NewFrom[T: numeric](values: [][]T): Matrix[T] {
	m := len(values)
	if m == 0 {
		ret uncheckedNew[T](0, 0)
	}

	n := len(values[0])
	if n == 0 {
		ret uncheckedNew[T](0, 0)
	}

	// Make sure all rows have same amount of values.
	// It also makes safe array access with no boundary check.
	mut j := 1
	for j < m; j++ {
		if len(values[j]) != n {
			panic("mat: NewFrom: rows have different amount of values")
		}
	}
	j = 0 // Set to zero to reuse.

	mut mat := uncheckedNew[T](m, n)
	mut k := 0
	for j < n; j++ {
		mut i := 0
		for i < m; i++ {
			mat.data[k] = values[i][j]
			k++
		}
	}

	ret mat
}

// Sets z to the sum x+y.
// z must be have enough space for the sum x+y.
#disable boundary
fn addRaw[T: numeric](mut &z: *Matrix[T], &x: *Matrix[T], &y: *Matrix[T]) {
	mut i := 0
	for i < len(z.data); i++ {
		z.data[i] = x.data[i] + y.data[i]
	}
}

// Sets z to the difference x-y.
// z must be have enough space for the difference x-y.
#disable boundary
fn subRaw[T: numeric](mut &z: *Matrix[T], &x: *Matrix[T], &y: *Matrix[T]) {
	mut i := 0
	for i < len(z.data); i++ {
		z.data[i] = x.data[i] - y.data[i]
	}
}

// Basic matrix multiplication implementation.
// Multiplies x and y and leaves the result in z.
// z must be have enough space for the product x*k.
// It will not update dimensions of the z.
#disable boundary
fn basicMul[T: numeric](mut &z: *Matrix[T], &x: *Matrix[T], &y: *Matrix[T]) {
	mut i := 0
	for i < x.m; i++ {
		mut zm := i + 0*z.m // i + j*z.m
		mut ym := 0 + 0*y.m // k + j*y.m

		mut j := 0
		for j < y.n; j, zm, ym = j+1, zm+z.m, ym+y.m {
			let mut sum: T
			mut k := 0
			for k < x.n; k++ {
				// Fast access form of: x.Get(i, k) * y.Get(k, j)
				sum += x.data[i+k*x.m] * y.data[k+ym]
			}
			// Fast access form of: z.Set(i, j, sum)
			z.data[zm] = sum
		}
	}
}

// Threshold for switching to basic multiplication.
// This value is crucial for performance, Strassen algorithm is inefficient for tiny matrices.
const strassenThreshold = 64

// Performs recursive Strassen matrix multiplication using single shared allocation.
// Assumes square matrices of size n × n where n is a power of 2.
// Writes final result to z, it must be have enough space for the product x*y.
#disable boundary
fn strassen[T: numeric](mut &z: *Matrix[T], mut &x: *Matrix[T], mut &y: *Matrix[T], mut space: []T) {
	// If the matrix size is small enough, use basic matrix multiplication.
	// This threshold balances recursion overhead and cache-local performance.
	// Threshold choice (e.g., 64) is crucial for performance and determines space needs.
	n := max(max(x.m, x.n), y.n)
	if n < strassenThreshold {
		basicMul(z, x, y)
		ret
	}

	// Half-size for quadrant splitting.
	k := n >> 1 // k = n / 2

	// Strassen requires 7 recursive multiplications and uses temporaries.
	// Allocate required submatrices from the workspace buffer:
	// - 7 intermediate result matrices (M1 through M7)
	// - 2 temporary matrices for sum/diff (S1, S2)
	// - 8 quadrant matrices (A11..A22, B11..B22) for copying subblocks

	// Each matrix is of size (k × k), so total allocation per level is:
	// 17 × (k × k) = 17k²

	// Allocate intermediate result matrices.
	mut m1 := getMatrix(k, k, &space)
	mut m2 := getMatrix(k, k, &space)
	mut m3 := getMatrix(k, k, &space)
	mut m4 := getMatrix(k, k, &space)
	mut m5 := getMatrix(k, k, &space)
	mut m6 := getMatrix(k, k, &space)
	mut m7 := getMatrix(k, k, &space)
	mut s1 := getMatrix(k, k, &space)
	mut s2 := getMatrix(k, k, &space)

	// Allocate quadrant matrices from input x.
	mut a11 := getMatrix(k, k, &space)
	copySubMatrix(&a11, x, 0, 0, k, k)
	mut a12 := getMatrix(k, k, &space)
	copySubMatrix(&a12, x, 0, k, k, k)
	mut a21 := getMatrix(k, k, &space)
	copySubMatrix(&a21, x, k, 0, k, k)
	mut a22 := getMatrix(k, k, &space)
	copySubMatrix(&a22, x, k, k, k, k)

	// Allocate quadrant matrices from input y.
	mut b11 := getMatrix(k, k, &space)
	copySubMatrix(&b11, y, 0, 0, k, k)
	mut b12 := getMatrix(k, k, &space)
	copySubMatrix(&b12, y, 0, k, k, k)
	mut b21 := getMatrix(k, k, &space)
	copySubMatrix(&b21, y, k, 0, k, k)
	mut b22 := getMatrix(k, k, &space)
	copySubMatrix(&b22, y, k, k, k, k)

	// M1 = (A11 + A22) * (B11 + B22)
	addRaw(&s1, &a11, &a22)
	addRaw(&s2, &b11, &b22)
	strassen(&m1, &s1, &s2, space)

	// M2 = (A21 + A22) * B11
	addRaw(&s1, &a21, &a22)
	strassen(&m2, &s1, &b11, space)

	// M3 = A11 * (B12 - B22)
	subRaw(&s1, &b12, &b22)
	strassen(&m3, &a11, &s1, space)

	// M4 = A22 * (B21 - B11)
	subRaw(&s1, &b21, &b11)
	strassen(&m4, &a22, &s1, space)

	// M5 = (A11 + A12) * B22
	addRaw(&s1, &a11, &a12)
	strassen(&m5, &s1, &b22, space)

	// M6 = (A21 - A11) * (B11 + B12)
	subRaw(&s1, &a21, &a11)
	addRaw(&s2, &b11, &b12)
	strassen(&m6, &s1, &s2, space)

	// M7 = (A12 - A22) * (B21 + B22)
	subRaw(&s1, &a12, &a22)
	addRaw(&s2, &b21, &b22)
	strassen(&m7, &s1, &s2, space)

	// C11 = M1 + M4 - M5 + M7
	addRaw(&s1, &m1, &m4)
	subRaw(&s2, &s1, &m5)
	addRaw(&s1, &s2, &m7)
	copyToQuadrant(z, &s1, 0, 0)

	// C12 = M3 + M5
	addRaw(&s1, &m3, &m5)
	copyToQuadrant(z, &s1, 0, k)

	// C21 = M2 + M4
	addRaw(&s1, &m2, &m4)
	copyToQuadrant(z, &s1, k, 0)

	// C22 = M1 - M2 + M3 + M6
	subRaw(&s1, &m1, &m2)
	addRaw(&s2, &s1, &m3)
	addRaw(&s1, &s2, &m6)
	copyToQuadrant(z, &s1, k, k)
}

// Places k matrix into a quadrant of z matrix at offset (m, n).
#disable boundary
fn copyToQuadrant[T: numeric](mut &z: *Matrix[T], &k: *Matrix[T], m: int, n: int) {
	mut kj := 0 * k.m             // j * k.m
	mut zm := (m + 0) + (n+0)*z.m // (m + i) + (n+j)*z.m
	mut j := 0
	for j < k.m; j, kj, zm = j+1, kj+k.m, zm+z.m {
		mut i := 0
		for i < k.m; i++ {
			// Fast access form of: z.Set(m+i, n+j, k.Get(i, j))
			z.data[i+zm] = k.data[i+kj]
		}
	}
}

// Copies submatrix (of m × n) from source k at (a, b) to z.
// z must be have enough space to copy k.
#disable boundary
fn copySubMatrix[T: numeric](mut &z: *Matrix[T], &k: *Matrix[T], a: int, b: int, m: int, n: int) {
	mut zm := 0 + 0*z.m           // i + j*z.m
	mut km := (a + 0) + (b+0)*k.m // (a + i) + (b+j)*k.m
	mut j := 0
	for j < n; j, zm, km = j+1, zm+z.m, km+k.m {
		mut i := 0
		for i < m; i++ {
			// Fast access form of: z.Set(i, j, k.Get(m+i, n+j))
			z.data[i+zm] = k.data[i+km]
		}
	}
}

// Pads and copies k matrix into larger workspace matrix z.
// Fills remaining elements with zeros.
// z must be have enough space to copy k.
#disable boundary
fn padAndCopy[T: numeric](mut &z: *Matrix[T], &k: *Matrix[T]) {
	// Clear the z matrix if k is smaller than.
	if k.m < z.m || k.n < z.n {
		for i in z.data {
			z.data[i] = 0
		}
	}

	mut zm := 0 + 0*z.m // i + j*z.m
	mut km := 0 + 0*k.m // i + j*k.m
	mut j := 0
	for j < k.n; j, zm, km = j+1, zm+z.m, km+k.m {
		mut i := 0
		for i < k.m; i++ {
			// Fast access form of: z.Set(i, j, k.Get(i, j))
			z.data[i+zm] = k.data[i+km]
		}
	}
}

// Returns new (M x N) Matrix for type T from space.
// The result matrix will use shared data from space.
// Space will be trimmed according to size.
fn getMatrix[T: numeric](m: int, n: int, mut &space: *[]T): Matrix[T] {
	k := m * n
	if k > len(*space) {
		panic("mat: getMatrix: internal error, no space")
	}
	mut data := (*space)[:k]
	*space = (*space)[k:]
	ret Matrix[T]{
		m: m,
		n: n,
		data: data,
	}
}

// Reports whether x and y share the same base array.
//
// Note: alias assumes that the capacity of underlying arrays
// is never changed for values; i.e. that there are
// no 3-operand slice expressions in this code (or worse,
// reflect-based operations to the same effect).
fn alias[T: numeric](x: []T, y: []T): bool {
	ret cap(x) > 0 && cap(y) > 0 && &x[0:cap(x)][cap(x)-1] == &y[0:cap(y)][cap(y)-1]
}

// https://graphics.stanford.edu/~seander/bithacks.html#DetermineIfPowerOf2
fn isPowerOfTwo(n: int): bool {
	ret n&(n-1) == 0
}

// https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
fn nextPowerOfTwo(mut n: int): int {
	if n <= 1 {
		ret 1
	}
	if isPowerOfTwo(n) {
		ret n
	}
	n--
	n |= n >> 1
	n |= n >> 2
	n |= n >> 4
	n |= n >> 8
	n |= n >> 16
	if uintSize == 64 { // 64-bit architecture
		n |= n >> 32
	}
	ret n + 1
}

fn max(x: int, y: int): int {
	if x > y {
		ret x
	}
	ret y
}