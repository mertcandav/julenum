// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// A matrix for type T.
// Uses internal mutable slice to store data.
// Matrix computations may use available capacity of the underlying slice
// to avoid making new allocation. So shared data needs extra attention.
// Any mutable operation may be reflected to shared common data.
// If you need to share same Matrix instance, use smart pointers.
// If you need to have guaranteed independent copy, use Copy with empty Matrix.
struct Matrix[T: numeric] {
	// Dimensions (m x n).
	m: int
	n: int

	// Data array, column-major.
	data: []T
}

impl Matrix {
	// Returns dimensions of the Matrix (m x n).
	fn Dims(*self): (m: int, n: int) {
		ret self.m, self.n
	}

	// Reports whether the all values of Matrix are zero.
	//
	// Special cases:
	//	IsZero() = true, if Dims() == (0, 0)
	fn IsZero(*self): bool {
		for _, x in self.data {
			if x != 0 {
				ret false
			}
		}
		ret true
	}

	// Reports whether the Matrix is a square matrix.
	fn IsSquare(*self): bool {
		ret self.m == self.n
	}

	// Returns value of the specified (i x j) position.
	// Position index starts from zero for column and row.
	//
	// Implementation will not check for boundaries, invalid position may cause panic.
	// To provide fast computation, it will not check whether the (i x j) is valid (m x n).
	fn Get(*self, i: int, j: int): T {
		ret self.data[i+j*self.m] // column-major
	}

	// Sets value of the specified (i x j) position.
	// Position index starts from zero for column and row.
	//
	// Implementation will not check for boundaries, invalid position may cause panic.
	// To provide fast computation, it will not check whether the (i x j) is valid (m x n).
	fn Set(mut *self, i: int, j: int, value: T) {
		self.data[i+j*self.m] = value // column-major
	}

	// Sets self to z, filled with k.
	// If self have enough capacity, Fill will use it to avoid making allocation.
	#disable boundary
	fn Fill(mut *self, &z: *Matrix[T], k: T) {
		// Make sure the self data have enough space.
		if cap(self.data) >= len(z.data) {
			// In this case, we have enough slice capacity or length to store result.
			// To avoid making allocation, use the full capacity if needed.
			self.data = self.data[:len(z.data)]
		} else {
			// No enough space, we have to allocate new slice.
			self.data = make([]T, len(z.data))
		}

		mut i := 0
		for i < len(z.data); i++ {
			self.data[i] = k
		}
	}

	// Copies z to self.
	//
	// If self have enough capacity, Copy will use it to avoid making allocation.
	fn Copy(mut *self, &z: *Matrix[T]) {
		// Fast case: if z and self is the same pointer.
		if self == z {
			ret
		}

		if cap(self.data) >= len(z.data) {
			// In this case, we have enough slice capacity or length to copy.
			// To avoid making allocation, use the full capacity if needed.
			self.data = self.data[:len(z.data)]
			copy(self.data, z.data)
		} else {
			// No enough space, we have to allocate new slice.
			self.data = make([]T, len(z.data))
			copy(self.data, z.data)
		}
	}

	// Returns trace of matrix.
	// Panics if matrix is not a square matrix.
	//
	// Special cases:
	//	Trace() = 0, for (0 x 0) matrices
	#disable boundary
	fn Trace(*self): T {
		if self.m != self.n {
			panic("mat: Matrix.Trace: trace computation on non-square matrix")
		}
		// Special case: trace of (0 x 0) matrix.
		if self.m == 0 {
			ret 0
		}
		// Compute trace of self.

		mut n := self.data[0]
		mut i := 1

		// The index on raw data for the matrix self.
		// Use for avoid to compute i+i*self.m for each iteration step.
		// It also eliminates multiplication, just basic binary addition.
		mut k := i + self.m

		for i < self.m; i, k = i+1, k+self.m+1 {
			n += self.data[k]
		}
		ret n
	}

	// Sets self to the transpose of the matrix z.
	// If self have enough capacity, Transpose will use it to avoid making allocation.
	// If z is a (0 x 0) matrix, self will be (0 x 0). But keeps internal allocation.
	#disable boundary
	fn Transpose(mut *self, &z: *Matrix[T]) {
		// Special case: (0 x 0) matrix.
		// Set self to (0 x 0), do not deallocate slice.
		if z.m == 0 && z.n == 0 {
			self.m, self.n = 0, 0
			ret
		}

		// (m x n) matrix will become (n x m).
		// So size will not be changed.
		// Make sure the self data have enough space.
		if self == z || alias(self.data, z.data) {
			// Matrix self and matrix z have shared data.
			// We have to allocate new Matrix to compute properly.
			mut r := uncheckedNew[T](z.n, z.m)
			r.Transpose(z)
			*self = r
			ret
		} else if cap(self.data) >= len(z.data) {
			// In this case, we have enough slice capacity or length to store result.
			// To avoid making allocation, use the full capacity if needed.
			self.data = self.data[:len(z.data)]
			// (m x n) matrix will become (n x m).
			self.m, self.n = z.n, z.m
		} else {
			// No enough space, we have to allocate new slice.
			self.data = make([]T, len(z.data))
			// (m x n) matrix will become (n x m).
			self.m, self.n = z.n, z.m
		}
		// Compute transpose of z.

		// The column index on raw data for the matrix z.
		// Use for avoid to compute j+i*z.m for each iteration step.
		// It also eliminates multiplication, just basic binary addition.
		mut zm := 0

		mut i := 0
		for i < z.n; i, zm = i+1, zm+z.m {
			// The index on raw data for the matrix self.
			// Use for avoid to compute i+j*self.m for each iteration step.
			// It eliminates multiplication, just basic binary addition.
			mut sm := i

			mut j := 0
			for j < z.m; j, sm = j+1, sm+self.m {
				self.data[sm] = z.data[j+zm] // column-major
			}
		}
	}
}

// Same as New, but it does not checks anything.
fn uncheckedNew[T: numeric](m: int, n: int): Matrix[T] {
	let mut mat: Matrix[T]
	mat.m, mat.n = m, n
	mat.data = make([]T, m*n)
	ret mat
}

// Returns new empty (0 x 0) Matrix for type T.
fn Empty[T: numeric](): Matrix[T] {
	ret uncheckedNew[T](0, 0)
}

// Returns new (m x n) Matrix for type T.
//
// Constraints:
//	m >= 0
//	n >= 0
fn New[T: numeric](m: int, n: int): Matrix[T] {
	if m < 0 || n < 0 {
		panic("mat: New: m < 0 || n < 0")
	}
	ret uncheckedNew[T](m, n)
}

// Returns new (m x n) Matrix for type T.
// Uses len(values) for m, len(values[1]) for n.
// Panics if all rows are not have same amount of values.
//
// Special cases:
//	NewFrom(values) = (0 x 0) Matrix, if len(values) == 0
//	NewFrom(values) = (0 x 0) Matrix, if len(values) == 1 && len(values[1]) == 0
//
// Example Use:
//
//	mat::NewFrom([
//		[1, 2, 4],
//		[3, 4, 5],
//	])
//
//	Equals to:
//		    ╭       ╮
//		    │ 1 2 4 │
//		A = │ 3 4 5 │
//		    ╰       ╯(2 x 3)
#disable boundary
fn NewFrom[T: numeric](values: [][]T): Matrix[T] {
	m := len(values)
	if m == 0 {
		ret uncheckedNew[T](0, 0)
	}

	n := len(values[0])
	if n == 0 {
		ret uncheckedNew[T](0, 0)
	}

	// Make sure all rows have same amount of values.
	// It also makes safe array access with no boundary check.
	mut j := 1
	for j < m; j++ {
		if len(values[j]) != n {
			panic("mat: NewFrom: rows have different amount of values")
		}
	}
	j = 0 // Set to zero to reuse.

	mut mat := uncheckedNew[T](m, n)
	mut k := 0
	for j < n; j++ {
		mut i := 0
		for i < m; i++ {
			mat.data[k] = values[i][j]
			k++
		}
	}

	ret mat
}

// Reports whether x and y share the same base array.
//
// Note: alias assumes that the capacity of underlying arrays
// is never changed for values; i.e. that there are
// no 3-operand slice expressions in this code (or worse,
// reflect-based operations to the same effect).
fn alias[T](x: []T, y: []T): bool {
	ret cap(x) > 0 && cap(y) > 0 && &x[0:cap(x)][cap(x)-1] == &y[0:cap(y)][cap(y)-1]
}