// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Represents a single term (monomial) of a polynomial.
// It has a coefficient and an exponent (degree).
//
// Mathematically, a term is expressed as:
//	coef * x^exp
//
// where:
// - coef ∈ ℝ (coefficient, a real number)
// - exp ∈ ℕ₀ (non-negative integer exponent)
//
// For example:
//	the term 3x² is represented as Term{Coef: 3, Exp: 2}.
//	the term 1 is represented as Term{Coef: 1, Exp: 0}
struct Term {
	Coef: f64
	Exp:  int
}

// Represents a polynomial as a slice of Terms.
//
// A polynomial P(x) is a finite sum of terms:
//	P(x) = Σᵢ [ Coefᵢ * x^Expᵢ ]
//
// where each Term is stored as an element of the Terms slice.
//
// Terms are expected to be stored in descending order of exponent (Exp),
// i.e., Terms[0].Exp > Terms[1].Exp > ... > Terms[n-1].Exp,
// which simplifies polynomial operations like addition and multiplication.
// Any corruption in this order is undefined behavior.
//
// Capacity of underlying slices is never changed for values; i.e. that there are
// no 3-operand slice expressions. Any corruption of this rule is undefined behavior.
type Polynomial: []Term

impl Polynomial {
	// Returns new Polynomial buffer enough to store at least n values.
	fn make(mut *self, n: int): Polynomial {
		// Reuse self capacity, if there is enough space.
		if n <= cap(*self) {
			ret (*self)[:n]
		}
		ret make(Polynomial, n)
	}

	// Sets self to sum x+y.
	//
	// If self have enough capacity, Add will use it to avoid making allocation.
	// If length is zero, self will be zero-length. But keeps internal allocation.
	#disable boundary
	fn Add(mut *self, &x: *Polynomial, &y: *Polynomial) {
		// If y is empty, just copy x.
		if len(*y) == 0 {
			// self is an x for self, return immediately.
			if self == x {
				ret
			}
			*self = self.make(len(*x))
			copy(*self, *x)
			ret
		}
		// If x is empty, just copy y.
		if len(*x) == 0 {
			// self is an alias for y, return immediately.
			if self == y {
				ret
			}
			*self = self.make(len(*y))
			copy(*self, *y)
			ret
		}

		// Allocate result Polynomial.
		let mut r: Polynomial
		if self == x || self == y || alias(self, x) || alias(self, y) {
			// self is an alias for x or y - cannot reuse.
			// We have to allocate new Matrix to compute properly.
			r = make(Polynomial, len(*x)+len(*y))
		} else {
			r = self.make(len(*x) + len(*y))
		}
		// compute x+y

		mut i, mut j, mut k := 0, 0, 0
		for i < len(*x) && j < len(*y) {
			xi, yj := (*x)[i], (*y)[j]
			if xi.Exp == yj.Exp {
				sumCoef := xi.Coef + yj.Coef
				if sumCoef != 0 {
					r[k] = Term{Coef: sumCoef, Exp: xi.Exp}
					k++
				}
				i++
				j++
			} else if xi.Exp > yj.Exp {
				r[k] = xi
				k++
				i++
			} else {
				r[k] = yj
				k++
				j++
			}
		}
		// Append remaining terms.
		for i < len(*x); i, k = i+1, k+1 {
			r[k] = (*x)[i]
		}
		for j < len(*y); j, k = j+1, k+1 {
			r[k] = (*y)[j]
		}

		// Trim to actual length.
		// Zero coefficients ignored, so final length may be different.
		*self = r[:k]
	}

	// Sets self to difference x-y.
	//
	// If self have enough capacity, Sub will use it to avoid making allocation.
	// If length is zero, self will be zero-length. But keeps internal allocation.
	#disable boundary
	fn Sub(mut *self, &x: *Polynomial, &y: *Polynomial) {
		// If y is empty, just copy x.
		if len(*y) == 0 {
			// self is an x for self, return immediately.
			if self == x {
				ret
			}
			*self = self.make(len(*x))
			copy(*self, *x)
			ret
		}
		// If x is empty, just copy y.
		if len(*x) == 0 {
			*self = self.make(len(*y))
			for (i, mut p) in *y {
				p.Coef = -p.Coef
				(*self)[i] = p
			}
			ret
		}

		// Allocate result Polynomial.
		let mut r: Polynomial
		if self == x || self == y || alias(self, x) || alias(self, y) {
			// self is an alias for x or y - cannot reuse.
			// We have to allocate new Matrix to compute properly.
			r = make(Polynomial, len(*x)+len(*y))
		} else {
			r = self.make(len(*x) + len(*y))
		}
		// compute x-y

		mut i, mut j, mut k := 0, 0, 0
		for i < len(*x) && j < len(*y) {
			xi, mut yj := (*x)[i], (*y)[j]
			if xi.Exp == yj.Exp {
				diffCoef := xi.Coef - yj.Coef
				if diffCoef != 0 {
					r[k] = Term{Coef: diffCoef, Exp: xi.Exp}
					k++
				}
				i++
				j++
			} else if xi.Exp > yj.Exp {
				r[k] = xi
				k++
				i++
			} else {
				yj.Coef = -yj.Coef
				r[k] = yj
				k++
				j++
			}
		}
		// Append remaining terms.
		for i < len(*x); i, k = i+1, k+1 {
			r[k] = (*x)[i]
		}
		for j < len(*y); j, k = j+1, k+1 {
			r[k] = Term{Coef: -(*y)[j].Coef, Exp: (*y)[j].Exp}
		}

		// Trim to actual length.
		// Zero coefficients ignored, so final length may be different.
		*self = r[:k]
	}
}

// Reports whether x and y share the same base array.
//
// Note: alias assumes that the capacity of underlying arrays
// is never changed for values; i.e. that there are
// no 3-operand slice expressions in this code (or worse,
// reflect-based operations to the same effect).
fn alias(&x: *Polynomial, &y: *Polynomial): bool {
	ret cap(*x) > 0 && cap(*y) > 0 && &((*x)[0:cap(*x)][cap(*x)-1]) == &((*y)[0:cap(*y)][cap(*y)-1])
}