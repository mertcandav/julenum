// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use jn "julenum"
use "std/math"
use "std/slices"
use "std/testing"

struct ioTest {
	input: Polynomial
	want:  Polynomial
}

let testsNegate: []ioTest = [
	{
		input: [{3, 2}, {-4, 1}, {1, 0}],
		want: [{-3, 2}, {4, 1}, {-1, 0}],
	},
	{
		input: [],
		want: [],
	},
	{
		input: [{0, 0}, {-1, 5}],
		want: [{0, 0}, {1, 5}],
	},
]

#test
fn testNegate(t: &testing::T) {
	for _, test in testsNegate {
		let mut r: Polynomial
		r.Negate(&test.input)
		if !slices::Equal([]Term(r), []Term(test.want)) {
			t.Errorf("Negate({}) = {}, expected {}", test.input, r, test.want)
		}
	}
}

let testsSimplify: []ioTest = [
	{
		input: [],
		want: [],
	},
	{
		input: [{3, 2}, {4, 2}, {-1, 1}, {1, 1}, {0, 0}],
		want: [{7, 2}],
	},
	{
		input: [{1, 0}, {-1, 0}],
		want: [],
	},
]

#test
fn testSimplify(t: &testing::T) {
	for _, test in testsSimplify {
		let mut r: Polynomial
		r.Simplify(&test.input, 0)
		if !slices::Equal([]Term(r), []Term(test.want)) {
			t.Logf("{} | {}", []Term(r), []Term(test.want))
			t.Errorf("Simplify({}, 0) = {}, expected {}", test.input, r, test.want)
		}
	}
}

struct testPolyCS {
	x:    Polynomial
	y:    Polynomial
	want: Polynomial
}

let testsAdd: []testPolyCS = [
	{
		x: [],
		y: [],
		want: [],
	},
	{
		x: [{2, 3}],
		y: [],
		want: [{2, 3}],
	},
	{
		x: [],
		y: [{2, 3}],
		want: [{2, 3}],
	},
	{
		x: [{3, 2}],
		y: [{2, 2}],
		want: [{5, 2}],
	},
	{
		x: [{3, 2}],
		y: [{-3, 2}],
		want: [],
	},
	{
		x: [{3, 3}, {1, 1}],
		y: [{2, 2}, {5, 1}],
		want: [{3, 3}, {2, 2}, {6, 1}],
	},
	{
		x: [{1, 5}, {2, 3}, {4, 1}],
		y: [{2, 4}, {3, 3}, {4, 0}],
		want: [{1, 5}, {2, 4}, {5, 3}, {4, 1}, {4, 0}],
	},
	{
		x: [{1, 2}, {1, 1}],
		y: [{1, 2}, {-1, 1}],
		want: [{2, 2}],
	},
]

#test
fn testAdd(t: &testing::T) {
	for _, test in testsAdd {
		let mut r: Polynomial
		r.Add(&test.x, &test.y)
		if !slices::Equal([]Term(r), []Term(test.want)) {
			t.Errorf("Add({}, {}) = {}, expected {}", test.x, test.y, r, test.want)
		}
	}
}

let testsSub: []testPolyCS = [
	{
		x: [],
		y: [],
		want: [],
	},
	{
		x: [{2, 3}],
		y: [],
		want: [{2, 3}],
	},
	{
		x: [],
		y: [{2, 3}],
		want: [{-2, 3}],
	},
	{
		x: [{5, 2}],
		y: [{3, 2}],
		want: [{2, 2}],
	},
	{
		x: [{5, 2}],
		y: [{5, 2}],
		want: [],
	},
	{
		x: [{3, 3}, {2, 1}],
		y: [{1, 3}, {5, 1}],
		want: [{2, 3}, {-3, 1}],
	},
	{
		x: [{2, 4}, {4, 2}, {1, 1}],
		y: [{1, 3}, {4, 2}, {3, 0}],
		want: [{2, 4}, {-1, 3}, {1, 1}, {-3, 0}],
	},
	{
		x: [{2, 5}, {3, 2}, {4, 0}],
		y: [{1, 5}, {3, 2}, {4, 0}],
		want: [{1, 5}],
	},
]

#test
fn testSub(t: &testing::T) {
	for _, test in testsSub {
		let mut r: Polynomial
		r.Sub(&test.x, &test.y)
		if !slices::Equal([]Term(r), []Term(test.want)) {
			t.Errorf("Sub({}, {}) = {}, expected {}", test.x, test.y, r, test.want)
		}
	}
}

struct scaleTest {
	p:    Polynomial
	k:    f64
	want: Polynomial
}

let testsScale: []scaleTest = [
	{
		p: [{3, 2}, {-2, 1}, {1, 0}],
		k: 2,
		want: [{6, 2}, {-4, 1}, {2, 0}],
	},
	{
		p: [{1.5, 3}, {-0.5, 1}],
		k: -2,
		want: [{-3, 3}, {1, 1}],
	},
	{
		p: [],
		k: 100,
		want: [],
	},
	{
		p: [{3, 2}],
		k: 0,
		want: [],
	},
]

#test
fn testScale(t: &testing::T) {
	for _, test in testsScale {
		let mut r: Polynomial
		r.Scale(&test.p, test.k)
		if !slices::Equal([]Term(r), []Term(test.want)) {
			t.Errorf("Scale({}, {}) = {}, expected {}", test.p, test.k, r, test.want)
		}
	}
}

let testsMulNaive: []testPolyCS = [
	{
		x: [],
		y: [],
		want: [],
	},
	{
		x: [{2, 3}],
		y: [],
		want: [],
	},
	{
		x: [],
		y: [{2, 3}],
		want: [],
	},
	{
		x: [{1, 0}],
		y: [{5, 0}],
		want: [{5, 0}],
	},
	{
		x: [{2, 1}, {1, 0}],                    // 2x + 1
		y: [{3, 2}, {1, 0}],                    // 3x² + 1
		want: [{6, 3}, {3, 2}, {2, 1}, {1, 0}], // 6x³ + 3x² + 2x + 1
	},
	{
		x: [{0, 3}, {4, 1}],
		y: [{3, 2}, {0, 0}],
		want: [{12, 3}],
	},
	{
		x: [{1, 1}, {1, 0}],
		y: [{-1, 1}, {1, 0}],
		// (x + 1)*( -x + 1) = -x² + x - x + 1 = -x² + 1
		want: [{-1, 2}, {1, 0}],
	},
	{
		x: [{1e-6, 0}],
		y: [{1e-7, 0}],
		want: [{1e-13, 0}],
	},
	{
		// 1e-6 * 1e-6 = 1e-12
		x: [{1e-6, 0}],
		y: [{1e-6, 0}],
		want: [{1e-12, 0}],
	},
	{
		// 1e-5 * 1e-6 = 1e-11
		x: [{1e-5, 0}],
		y: [{1e-6, 0}],
		want: [{1e-11, 0}],
	},
	{
		// 1e-5 * 1e-5 = 1e-10
		x: [{1e-5, 0}],
		y: [{1e-5, 0}],
		want: [{1e-10, 0}],
	},
	{
		// 1e-1 * 1e-1 = 1e-2
		x: [{1e-1, 0}],
		y: [{1e-1, 0}],
		want: [{1e-2, 0}],
	},
	{
		// 1e-1 * 9e-1 = 9e-2
		x: [{1e-1, 0}],
		y: [{9e-1, 0}],
		want: [{9e-2, 0}],
	},
	{
		// 1e-6 * 1e-6 = 1e-12
		x: [{1e-6, 0}],
		y: [{1e-6, 0}],
		want: [{1e-12, 0}],
	},
	{
		// 5e-6 * 2e-6 = 1e-11
		x: [{5e-6, 1}],
		y: [{2e-6, 2}],
		want: [{1e-11, 3}],
	},
	{
		x: [{1e-5, 3}],
		y: [{1e-5, 4}],
		want: [{1e-10, 7}],
	},
	{
		x: [{5e-7, 3}],
		y: [{5e-7, 4}],
		want: [{2.5e-13, 7}],
	},
	{
		x: [{9e-7, 0}, {2e-6, 2}],
		y: [{2e-7, 0}, {1e-7, 1}],
		want: [
			{2e-13, 3},
			{4e-13, 2},
			{9e-14, 1},
			{1.8e-13, 0},
		],
	},
	{
		x: [{1e-6, 0}, {2e-7, 1}],
		y: [{1e-7, 0}, {3e-7, 1}],
		want: [
			{6e-14, 2},         // 2e-7 * 3e-7
			{3e-13 + 2e-14, 1}, // 1e-6*3e-7 + 2e-7*1e-7
			{1e-13, 0},         // 1e-6 * 1e-7
		],
	},
	{
		x: [{1, 0}, {1, 1}, {1, 2}, {1, 3}, {1, 4}],
		y: [{1, 0}, {1, 1}, {1, 2}, {1, 3}, {1, 4}],
		want: [{1, 8}, {2, 7}, {3, 6}, {4, 5}, {5, 4}, {4, 3}, {3, 2}, {2, 1}, {1, 0}],
	},
]

#test
fn testMulNaive(t: &testing::T) {
	for _, test in testsMulNaive {
		let mut r: Polynomial
		r.MulNaive(&test.x, &test.y)
		if len(r) != len(test.want) {
			t.Errorf("MulNaive({}, {}) = {}, expected {}", test.x, test.y, r, test.want)
			continue
		}
		mut i := 0
		for i < len(r); i++ {
			want := test.want[i]
			if !jn::Close(r[i].Coef, want.Coef) ||
				!jn::Close(f64(r[i].Exp), f64(want.Exp)) {
				t.Errorf("MulNaive({}, {})[{}] = {}, expected {}", test.x, test.y, i, r[i], want)
				break
			}
		}
	}
}

#test
#disable boundary
fn testMulFFT(t: &testing::T) {
	// Use naive multiplication tests to test accuracy and stay close to naive.
	for _, test in testsMulNaive {
		size := fftSize(&test.x, &test.y)
		tol := dynamicTolerance(&test.x, &test.y, size)

		let mut r: Polynomial
		r.MulFFT(&test.x, &test.y, tol)
		if len(r) != len(test.want) {
			t.Errorf("MulFFT({}, {}) = {}, expected {}", test.x, test.y, r, test.want)
			continue
		}
		mut i := 0
		for i < len(r); i++ {
			want := test.want[i]
			if !jn::Close(r[i].Coef, want.Coef) ||
				!jn::Close(f64(r[i].Exp), f64(want.Exp)) {
				t.Errorf("MulFFT({}, {})[{}] = {}, expected {}", test.x, test.y, i, r[i], want)
				break
			}
		}
	}

	// Test dynamic tolerance and FFT on large polynomials and exp.
	sizes := [128, 158, 199, 256, 512, 1000, 2048, 1 << 14, 1 << 16]
	for _, n in sizes {
		mut x := make(Polynomial, n)
		mut y := make(Polynomial, n)

		mut i := 0
		for i < n; i++ {
			x[i] = Term{Coef: 1, Exp: i}
			y[i] = Term{Coef: 1, Exp: i}
		}

		size := fftSize(&x, &y)
		tol := dynamicTolerance(&x, &y, size)
		x.MulFFT(&x, &y, tol)

		if len(x) != 2*n-1 {
			t.Errorf("Expected result length {}, got {}", 2*n-1, len(x))
			ret
		}
		if !jn::Tolerance(x[0].Coef, 1, tol) || !jn::Tolerance(x[1].Coef, 2, tol) ||
			!jn::Tolerance(x[n-1].Coef, f64(n), tol) || !jn::Tolerance(x[2*n-2].Coef, 1, tol) {
			t.Errorf("Incorrect FFT result for dense input")
		}
	}
}

struct testDiv {
	x:    Polynomial
	y:    Polynomial
	quot: Polynomial
	rem:  Polynomial
}

let testsDivMod: []testDiv = [
	// 0 / (x + 1) = 0, remainder 0
	{
		x: [],
		y: [{1, 1}, {1, 0}],
		quot: [],
		rem: [{1, 1}, {1, 0}],
	},
	// (x + 4) / (x^2 + 1) = 0, remainder x + 4
	{
		x: [{1, 1}, {4, 0}],
		y: [{1, 2}, {1, 0}],
		quot: [],
		rem: [{1, 1}, {4, 0}],
	},
	// (x^2 + 3x + 2) / (x + 1) = x + 2, remainder 0
	{
		x: [{1, 2}, {3, 1}, {2, 0}],
		y: [{1, 1}, {1, 0}],
		quot: [{1, 1}, {2, 0}],
		rem: [],
	},
	// (2x^2 + 3x + 1) / (x + 1) = 2x + 1, remainder 0
	{
		x: [{2, 2}, {3, 1}, {1, 0}],
		y: [{1, 1}, {1, 0}],
		quot: [{2, 1}, {1, 0}],
		rem: [],
	},
	// (x^3 - 2x + 4) / (x - 1) = x^2 + x - 1, remainder 3
	{
		x: [{1, 3}, {-2, 1}, {4, 0}],
		y: [{1, 1}, {-1, 0}],
		quot: [{1, 2}, {1, 1}, {-1, 0}],
		rem: [{3, 0}],
	},
	// (x^2 + 1) / (x^3 + 2) = quotient = 0, remainder = dividend
	{
		x: [{1, 2}, {1, 0}],
		y: [{1, 3}, {2, 0}],
		quot: [],
		rem: [{1, 2}, {1, 0}],
	},
	// (x^2 + 5x + 6) / (x + 2) = quotient x + 3, remainder = 0
	{
		x: [{1, 2}, {5, 1}, {6, 0}],
		y: [{1, 1}, {2, 0}],
		quot: [{1, 1}, {3, 0}],
		rem: [],
	},
	// (x^3 + 4x^2 + 7x - 5) / (x - 1) = quotient x^2 + 3x + 4, remainder = -1
	{
		x: [{1, 3}, {4, 2}, {7, 1}, {-5, 0}],
		y: [{1, 1}, {-1, 0}],
		quot: [{1, 2}, {5, 1}, {12, 0}],
		rem: [{7, 0}],
	},
	// (2x^4 + 3x^3 - x^2 + 5x - 8) / (x^2 + x - 2) = quotient x^2 + x + 3, remainder = 10x - 2
	{
		x: [{2, 4}, {3, 3}, {-1, 2}, {5, 1}, {-8, 0}],
		y: [{1, 2}, {1, 1}, {-2, 0}],
		quot: [{2, 2}, {1, 1}, {2, 0}],
		rem: [{5, 1}, {-4, 0}],
	},
	// (x^5 + 1) / (x + 1) = quotient x^4 - x^3 + x^2 - x + 1, remainder = 0
	{
		x: [{1, 5}, {1, 0}],
		y: [{1, 1}, {1, 0}],
		quot: [{1, 4}, {-1, 3}, {1, 2}, {-1, 1}, {1, 0}],
		rem: [],
	},
	// (3x^3 - 2x + 1) / (x^2 + 1) = quotient 3x, remainder = -5x + 1
	{
		x: [{3, 3}, {-2, 1}, {1, 0}],
		y: [{1, 2}, {1, 0}],
		quot: [{3, 1}],
		rem: [{-5, 1}, {1, 0}],
	},
]

#test
fn testDivMod(t: &testing::T) {
	for _, test in testsDivMod {
		let mut r: Polynomial
		let mut rem: Polynomial

		testDivMod := fn(name: str, r: Polynomial, rem: Polynomial) {
			if len(r) != len(test.quot) {
				t.Errorf("{}({}, {}) = {}, expected {}", name, test.x, test.y, r, test.quot)
				ret
			}
			mut i := 0
			for i < len(r); i++ {
				want := test.quot[i]
				if !jn::Close(r[i].Coef, want.Coef) ||
					!jn::Close(f64(r[i].Exp), f64(want.Exp)) {
					t.Errorf("{}({}, {})[{}] = {}, expected {}", name, test.x, test.y, i, r[i], want)
					break
				}
			}

			if len(rem) != len(test.rem) {
				t.Errorf("{}({}, {}) = rem {}, expected {}", name, test.x, test.y, r, test.rem)
				ret
			}
			i = 0
			for i < len(rem); i++ {
				want := test.rem[i]
				if !jn::Close(rem[i].Coef, want.Coef) ||
					!jn::Close(f64(rem[i].Exp), f64(want.Exp)) {
					t.Errorf("{}({}, {})[{}] = rem {}, expected {}", name, test.x, test.y, i, rem[i], want)
					break
				}
			}
		}

		r.DivMod(&test.x, &test.y, &rem)
		testDivMod("DivMod", r, rem)
		fftDivMod(&r, &test.x, &test.y, &rem)
		testDivMod("DivModFFT", r, rem)
	}
}

let testsDerivative: []ioTest = [
	// d/dx (5) = 0
	{
		input: [{5, 0}],
		want: [],
	},

	// d/dx (3x) = 3
	{
		input: [{3, 1}],
		want: [{3, 0}],
	},

	// d/dx (3 + 2x + 5x^3) = 2 + 15x^2
	{
		input: [
			{3, 0},
			{2, 1},
			{5, 3},
		],
		want: [
			{2, 0},
			{15, 2},
		],
	},

	// d/dx (x^5 - 2x^3 + x) = 5x^4 - 6x^2 + 1
	{
		input: [{1, 1}, {-2, 3}, {1, 5}],
		want: [
			{1, 0},
			{-6, 2},
			{5, 4},
		],
	},
]

#test
fn testDerivative(t: &testing::T) {
	for _, test in testsDerivative {
		let mut r: Polynomial
		r.Derivative(&test.input)
		if !slices::Equal([]Term(r), []Term(test.want)) {
			t.Errorf("Derivative({}) = {}, expected {}", test.input, r, test.want)
		}
	}
}

struct evalTest {
	p:    Polynomial
	x:    f64
	want: f64
}

let testsEval: []evalTest = [
	// P(x) = 0
	{[], 1.0, 0},

	// P(x) = 5
	{[{5, 0}], 2.0, 5},

	// P(x) = x
	{[{1, 1}], 3.0, 3},

	// P(x) = x^2 + 2x + 1
	{[{1, 2}, {2, 1}, {1, 0}], 2.0, 9},

	// P(x) = 2x^3 - x + 4
	//      = 16 - 2 + 4 = 18
	{[{2, 3}, {-1, 1}, {4, 0}], 2.0, 2*8 - 2 + 4},

	// P(x) = x^10 at x = 1 → 1
	{[{1, 10}], 1.0, 1},

	// P(x) = 7x^5 - 3x^2 + x at x = 2
	//      = 224 - 12 + 2 = 214
	{[{7, 5}, {-3, 2}, {1, 1}], 2.0, 7*32 - 3*4 + 2},
]

#test
fn testEval(t: &testing::T) {
	for _, test in testsEval {
		got := test.p.Eval(test.x)
		if got != test.want {
			t.Errorf("Eval({}) = {}, expected {}", test.x, got, test.want)
		}
	}
}