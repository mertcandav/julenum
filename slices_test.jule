// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/math"
use "std/testing"

struct csTest {
	s:   []f64
	max: f64
	min: f64
	sum: f64
}

let testsCS: []csTest = [
	{s: [1, 2, 3, 4, 5, 6], max: 6, min: 1, sum: 21},
	{s: [9, 0], max: 9, min: 0, sum: 9},
	{s: [2], max: 2, min: 2, sum: 2},
	{s: [-2], max: -2, min: -2, sum: -2},
	{s: [math::NaN(), -2], max: math::NaN(), min: math::NaN(), sum: math::NaN()},
	{s: [math::NaN()], max: math::NaN(), min: math::NaN(), sum: math::NaN()},
	{s: [math::NaN(), math::Inf(+1)], max: math::NaN(), min: math::NaN(), sum: math::NaN()},
	{s: [math::Inf(-1), math::Inf(+1)], max: math::Inf(+1), min: math::Inf(-1), sum: math::NaN()},
	{s: [math::Inf(+1), math::Inf(-1)], max: math::Inf(+1), min: math::Inf(-1), sum: math::NaN()},
	{s: [math::Inf(+1), math::Inf(+1)], max: math::Inf(+1), min: math::Inf(+1), sum: math::Inf(+1)},
	{s: [math::Inf(-1), math::Inf(-1)], max: math::Inf(-1), min: math::Inf(-1), sum: math::Inf(-1)},
	{s: [9735, f64.Max, math::Inf(+1)], max: math::Inf(+1), min: 9735, sum: math::Inf(+1)},
]

#test
fn testMax(t: &testing::T) {
	for _, test in testsCS {
		max := Max(test.s...)
		if !Equal(max, test.max) {
			t.Errorf("Max({}) = {}, expected {}", test.s, max, test.max)
		}
	}
}

#test
fn testMin(t: &testing::T) {
	for _, test in testsCS {
		min := Min(test.s...)
		if !Equal(min, test.min) {
			t.Errorf("Min({}) = {}, expected {}", test.s, min, test.min)
		}
	}
}

#test
fn testSum(t: &testing::T) {
	for _, test in testsCS {
		sum := Sum(test.s...)
		if !Equal(sum, test.sum) {
			t.Errorf("Sum({}) = {}, expected {}", test.s, sum, test.sum)
		}
	}
}

struct linspaceTest {
	start: f64
	stop:  f64
	n:     int
	want:  []f64
}

let testsLinspace: []linspaceTest = [
	{
		start: 1, stop: 1, n: 0,
		want: [],
	},
	{
		start: 1, stop: 2, n: 1,
		want: [1],
	},
	{
		start: 1, stop: 1, n: 5,
		want: [1, 1, 1, 1, 1],
	},
	{
		start: 1, stop: 2, n: 5,
		want: [1, 1.25, 1.5, 1.75, 2],
	},
	{
		start: 2, stop: 1, n: 5,
		want: [2, 1.75, 1.5, 1.25, 1],
	},
	{
		start: 1, stop: 2, n: 4,
		want: [1, 1.3333333333333333, 1.6666666666666665, 2],
	},
	{
		start: 2, stop: 1, n: 4,
		want: [2, 1.6666666666666665, 1.3333333333333333, 1],
	},
	{
		start: -1, stop: 1, n: 4,
		want: [-1, -0.33333333333333337, 0.33333333333333326, 1],
	},
	{
		start: 1, stop: -1, n: 4,
		want: [1, 0.33333333333333337, -0.33333333333333326, -1],
	},
	{
		start: math::NaN(), stop: 2, n: 4,
		want: [math::NaN(), math::NaN(), math::NaN(), math::NaN()],
	},
	{
		start: 1, stop: math::NaN(), n: 4,
		want: [1, math::NaN(), math::NaN(), math::NaN()],
	},
	{
		start: math::Inf(+1), stop: math::Inf(+1), n: 4,
		want: [math::Inf(+1), math::NaN(), math::NaN(), math::NaN()],
	},
	{
		start: math::Inf(-1), stop: math::Inf(+1), n: 4,
		want: [math::Inf(-1), math::NaN(), math::NaN(), math::NaN()],
	},
]

#test
fn testLinspace(t: &testing::T) {
	for _, test in testsLinspace {
		got := Linspace(test.start, test.stop, test.n)
		if len(got) != len(test.want) {
			t.Errorf("Linspace({}, {}, {}) = {}, expected {}", test.start, test.stop, test.n, got, test.want)
			continue
		}
		for i in got {
			if !Equal(got[i], test.want[i]) && !VeryClose(got[i], test.want[i]) {
				t.Errorf("Linspace({}, {}, {}) = {}, expected {}", test.start, test.stop, test.n, got, test.want)
				break
			}
		}
	}
}